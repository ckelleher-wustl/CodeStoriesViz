<div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal0">
		<legend>Sub-goal</legend>
		<div>Read in an example image using Python</div>
	</fieldset>
<button type='button' class='collapsible'>main.py: import scipy and pandas</button>
<div class='content' --start-code='' --end-code='import scipy
import pandas' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region0')">from PIL import Image</li>
</ul>
</div><button type='button' class='collapsible'>main.py: attempt to read image using imageio</button>
<div class='content' --start-code='import scipy
import pandas' --end-code='# import imageio.v3 as iio

# target_photo = "target_photo.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region0')">from PIL import Image</li>
</ul>
</div><button type='button' class='collapsible'>search: imageio ndimage;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=imageio+python&rlz=1C5CHFA_enUS863US865&oq=imageio+py&aqs=chrome.0.0i20i263i512j69i57j0i20i263i512j0i512l7.3097j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=imageio+python&rlz=1C5CHFA_enUS863US865&oq=imageio+py&aqs=chrome.0.0i20i263i512j69i57j0i20i263i512j0i512l7.3097j0j7&sourceid=chrome&ie=UTF-8")'>imageio python</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot9.png' width='180' height='112'> </td></tr><tr><td><a href='https://imageio.readthedocs.io/en/stable/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://imageio.readthedocs.io/en/stable/")'>Welcome to imageios documentation!  imageio 2.25.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot10.png' width='180' height='112'> </td></tr><tr><td><a href='https://imageio.readthedocs.io/en/stable/examples.html#read-an-image-of-a-cat' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://imageio.readthedocs.io/en/stable/examples.html#read-an-image-of-a-cat")'>Imageio Usage Examples  imageio 2.25.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot17.png' width='180' height='112'> </td></tr><tr><td><a href='https://imageio.readthedocs.io/en/stable/reference/index.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://imageio.readthedocs.io/en/stable/reference/index.html")'>API Reference  imageio 2.25.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot14.png' width='180' height='112'> </td></tr><tr><td><a href='https://imageio.readthedocs.io/en/stable/_autosummary/imageio.v3.imread.html#imageio.v3.imread' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://imageio.readthedocs.io/en/stable/_autosummary/imageio.v3.imread.html#imageio.v3.imread")'>imageio.v3.imread  imageio 2.25.1 documentation</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=imageio+ndimage&rlz=1C5CHFA_enUS863US865&oq=imageio+ndimage&aqs=chrome..69i57j33i160.2401j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=imageio+ndimage&rlz=1C5CHFA_enUS863US865&oq=imageio+ndimage&aqs=chrome..69i57j33i160.2401j0j7&sourceid=chrome&ie=UTF-8")'>imageio ndimage</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot17.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://imageio.readthedocs.io/en/stable/reference/index.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://imageio.readthedocs.io/en/stable/reference/index.html")'>API Reference  imageio 2.25.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot14.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://imageio.readthedocs.io/en/stable/_autosummary/imageio.v3.imread.html#imageio.v3.imread' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://imageio.readthedocs.io/en/stable/_autosummary/imageio.v3.imread.html#imageio.v3.imread")'>imageio.v3.imread  imageio 2.25.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot15.png' width='180' height='112'> </td></tr><tr><td><a href='https://github.com/imageio/imageio/blob/v2.25.1/imageio/v3.py#L6-L54' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://github.com/imageio/imageio/blob/v2.25.1/imageio/v3.py#L6-L54")'>imageio/v3.py at v2.25.1 · imageio/imageio · GitHub</a></td></tr></tbody></table></div>
</div>
</div>

<button type='button' class='collapsible'>main.py: Switch to PIL (Python Image Library) and read in an image</button>
<div class='content' --start-code='# import imageio.v3 as iio

# target_photo = "target_photo.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image


basewidth = 50
img = Image.open(target_photo)
wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)
image_matrix = img.load()
print(img.shape)



#img.save("resized_image.jpg")' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region1')">def get_avg_pixel(img):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region9')">def scale_image_to_basewidth(img, basewidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region25')">    #get list of all centroids</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region26')">    img = scale_image_to_basewidth(img, basewidth=50)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region31')">def make_mosaic_avg(target_photo, photos_dir=Photos/, basewidth=50, pixelWidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region34')">basewidth = 60</li>
</ul>
</div><button type='button' class='collapsible'>search: husky clip art;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=dog+clip+art&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzW89e1J4Qr0B_Aazp8ehihlHUq-2Q:1676494977573&source=lnms&tbm=isch&sa=X&ved=2ahUKEwifh-y8tpj9AhXBkokEHS1iB9cQ_AUoAXoECAEQAw&biw=1680&bih=914&dpr=1' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=dog+clip+art&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzW89e1J4Qr0B_Aazp8ehihlHUq-2Q:1676494977573&source=lnms&tbm=isch&sa=X&ved=2ahUKEwifh-y8tpj9AhXBkokEHS1iB9cQ_AUoAXoECAEQAw&biw=1680&bih=914&dpr=1")'>dog clip art</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=husky+clip+art&tbm=isch&ved=2ahUKEwil8--9tpj9AhUA8ckDHdtHDFsQ2-cCegQIABAA&oq=husky+clip+art&gs_lcp=CgNpbWcQAzIFCAAQgAQyBQgAEIAEMgUIABCABDIGCAAQBxAeMgYIABAHEB4yBggAEAcQHjIGCAAQBRAeMgYIABAFEB4yBggAEAgQHjIGCAAQCBAeOgcIABCxAxBDOggIABCABBCxAzoICAAQBRAHEB5QlQlYmg1gmg5oAHAAeACAAUyIAZADkgEBNpgBAKABAaoBC2d3cy13aXotaW1nwAEB&sclient=img&ei=g0jtY-WlLIDip84P24-x2AU&bih=914&biw=1680&rlz=1C5CHFA_enUS863US865' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=husky+clip+art&tbm=isch&ved=2ahUKEwil8--9tpj9AhUA8ckDHdtHDFsQ2-cCegQIABAA&oq=husky+clip+art&gs_lcp=CgNpbWcQAzIFCAAQgAQyBQgAEIAEMgUIABCABDIGCAAQBxAeMgYIABAHEB4yBggAEAcQHjIGCAAQBRAeMgYIABAFEB4yBggAEAgQHjIGCAAQCBAeOgcIABCxAxBDOggIABCABBCxAzoICAAQBRAHEB5QlQlYmg1gmg5oAHAAeACAAUyIAZADkgEBNpgBAKABAaoBC2d3cy13aXotaW1nwAEB&sclient=img&ei=g0jtY-WlLIDip84P24-x2AU&bih=914&biw=1680&rlz=1C5CHFA_enUS863US865")'>husky clip art</a></span></div><hr>
<div class='webImageLongRow'>
</div>
</div>

<button type='button' class='collapsible'>search: house clipart jpg;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=house+clipart+jpeg&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVsexrAbx06nNxyOW3PoWHMgkKB-Q:1676495089748&source=lnms&tbm=isch&sa=X&ved=2ahUKEwjp0arytpj9AhUSkokEHS-CDlgQ_AUoAXoECAEQAw&biw=1680&bih=914&dpr=1' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=house+clipart+jpeg&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVsexrAbx06nNxyOW3PoWHMgkKB-Q:1676495089748&source=lnms&tbm=isch&sa=X&ved=2ahUKEwjp0arytpj9AhUSkokEHS-CDlgQ_AUoAXoECAEQAw&biw=1680&bih=914&dpr=1")'>house clipart jpeg</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=house+clipart+jpg&tbm=isch&rlz=1C5CHFA_enUS863US865&hl=en&sa=X&ved=2ahUKEwi6lrnztpj9AhUz6MkDHa8ND38QBXoECAEQPw&biw=1665&bih=914' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=house+clipart+jpg&tbm=isch&rlz=1C5CHFA_enUS863US865&hl=en&sa=X&ved=2ahUKEwi6lrnztpj9AhUz6MkDHa8ND38QBXoECAEQPw&biw=1665&bih=914")'>house clipart jpg</a></span></div><hr>
<div class='webImageLongRow'>
</div>
</div>

</div><div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal8">
		<legend>Sub-goal</legend>
		<div>Calculate average pixel of image</div>
	</fieldset>
<button type='button' class='collapsible'>search: python pil iterate over pixels;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=python+pil+iterate+over+pixels&rlz=1C5CHFA_enUS863US865&oq=python+pil+iterate&aqs=chrome.0.0i512j69i57j0i22i30i625j0i390l2.2481j0j9&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+pil+iterate+over+pixels&rlz=1C5CHFA_enUS863US865&oq=python+pil+iterate&aqs=chrome.0.0i512j69i57j0i22i30i625j0i390l2.2481j0j9&sourceid=chrome&ie=UTF-8")'>python pil iterate over pixels</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot22.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/3971459/how-to-loop-all-image-pixels-and-tell-whether-they-are-black-or-white' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/3971459/how-to-loop-all-image-pixels-and-tell-whether-they-are-black-or-white")'>python - How to loop all image pixels and tell whether they are black or white - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot21.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.geeksforgeeks.org/python-pil-image-resize-method/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://www.geeksforgeeks.org/python-pil-image-resize-method/")'>Python PIL | Image.resize() method - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>
</div>

<button type='button' class='collapsible'>search: fastest way to calculate average color of image in python;'</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot22.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://stackoverflow.com/questions/3971459/how-to-loop-all-image-pixels-and-tell-whether-they-are-black-or-white' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://stackoverflow.com/questions/3971459/how-to-loop-all-image-pixels-and-tell-whether-they-are-black-or-white")'>python - How to loop all image pixels and tell whether they are black or white - Stack Overflow</a></td></tr></tbody></table></div>
<div class='title'><span><a href='https://www.google.com/search?q=An+image+access+object&rlz=1C5CHFA_enUS863US865&oq=An+image+access+object&aqs=chrome..69i57j33i15i22i29i30j33i22i29i30j33i15i22i29i30i625j33i22i29i30i625.364j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=An+image+access+object&rlz=1C5CHFA_enUS863US865&oq=An+image+access+object&aqs=chrome..69i57j33i15i22i29i30j33i22i29i30j33i15i22i29i30i625j33i22i29i30i625.364j0j7&sourceid=chrome&ie=UTF-8")'>An image access object</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot23.png' width='180' height='112'> </td></tr><tr><td><a href='https://learn.microsoft.com/en-us/office/vba/api/access.image' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://learn.microsoft.com/en-us/office/vba/api/access.image")'>Image object (Access) | Microsoft Learn</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot24.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/21030459/how-to-iterate-correctly-over-a-pixel-access-object-from-pil' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/21030459/how-to-iterate-correctly-over-a-pixel-access-object-from-pil")'>python - How to iterate correctly over a pixel access object from PIL? - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot45.png' width='180' height='112'> </td></tr><tr><td><a href='https://note.nkmk.me/en/python-opencv-pillow-image-size/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://note.nkmk.me/en/python-opencv-pillow-image-size/")'>Get image size (width, height) with Python, OpenCV, Pillow (PIL) | note.nkmk.me</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot29.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/43111029/how-to-find-the-average-colour-of-an-image-in-python-with-opencv' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/43111029/how-to-find-the-average-colour-of-an-image-in-python-with-opencv")'>How to find the average colour of an image in Python with OpenCV? - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+get+average+color+of+image&rlz=1C5CHFA_enUS863US865&oq=python+get+average+color+of+image&aqs=chrome.0.0i512j69i57.3585j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+get+average+color+of+image&rlz=1C5CHFA_enUS863US865&oq=python+get+average+color+of+image&aqs=chrome.0.0i512j69i57.3585j0j7&sourceid=chrome&ie=UTF-8")'>python get average color of image</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+get+average+color+of+image+pil&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVvlF7GmE22_gPAwLcxqpTVNvL1uQ%3A1676495886167&ei=DkztY9vFCe-bptQPlJyV6A4&ved=0ahUKEwjbhIzuuZj9AhXvjYkEHRROBe0Q4dUDCBA&uact=5&oq=python+get+average+color+of+image+pil&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAEyBQghEKABOgQIABBHOgkIABAWEB4Q8QQ6BQgAEIYDOgUIIRCrAjoLCCEQFhAeEPEEEB1KBAhBGABKBAhGGABQvQRYggpgwwtoAHACeACAAX-IAZwDkgEDMi4ymAEAoAEByAEIwAEB&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+get+average+color+of+image+pil&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVvlF7GmE22_gPAwLcxqpTVNvL1uQ%3A1676495886167&ei=DkztY9vFCe-bptQPlJyV6A4&ved=0ahUKEwjbhIzuuZj9AhXvjYkEHRROBe0Q4dUDCBA&uact=5&oq=python+get+average+color+of+image+pil&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAEyBQghEKABOgQIABBHOgkIABAWEB4Q8QQ6BQgAEIYDOgUIIRCrAjoLCCEQFhAeEPEEEB1KBAhBGABKBAhGGABQvQRYggpgwwtoAHACeACAAX-IAZwDkgEDMi4ymAEAoAEByAEIwAEB&sclient=gws-wiz-serp")'>python get average color of image pil</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot45.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://note.nkmk.me/en/python-opencv-pillow-image-size/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://note.nkmk.me/en/python-opencv-pillow-image-size/")'>Get image size (width, height) with Python, OpenCV, Pillow (PIL) | note.nkmk.me</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot28.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.google.com/search?q=python+get+average+color+of+image+pil&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVvlF7GmE22_gPAwLcxqpTVNvL1uQ%3A1676495886167&ei=DkztY9vFCe-bptQPlJyV6A4&ved=0ahUKEwjbhIzuuZj9AhXvjYkEHRROBe0Q4dUDCBA&uact=5&oq=python+get+average+color+of+image+pil&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAEyBQghEKABOgQIABBHOgkIABAWEB4Q8QQ6BQgAEIYDOgUIIRCrAjoLCCEQFhAeEPEEEB1KBAhBGABKBAhGGABQvQRYggpgwwtoAHACeACAAX-IAZwDkgEDMi4ymAEAoAEByAEIwAEB&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://www.google.com/search?q=python+get+average+color+of+image+pil&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVvlF7GmE22_gPAwLcxqpTVNvL1uQ%3A1676495886167&ei=DkztY9vFCe-bptQPlJyV6A4&ved=0ahUKEwjbhIzuuZj9AhXvjYkEHRROBe0Q4dUDCBA&uact=5&oq=python+get+average+color+of+image+pil&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAEyBQghEKABOgQIABBHOgkIABAWEB4Q8QQ6BQgAEIYDOgUIIRCrAjoLCCEQFhAeEPEEEB1KBAhBGABKBAhGGABQvQRYggpgwwtoAHACeACAAX-IAZwDkgEDMi4ymAEAoAEByAEIwAEB&sclient=gws-wiz-serp")'>python get average color of image pil</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot29.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://stackoverflow.com/questions/43111029/how-to-find-the-average-colour-of-an-image-in-python-with-opencv' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://stackoverflow.com/questions/43111029/how-to-find-the-average-colour-of-an-image-in-python-with-opencv")'>How to find the average colour of an image in Python with OpenCV? - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=fastest+way+to+calculate+average+color+of+image+in+python&rlz=1C5CHFA_enUS863US865&oq=fastest+way+to+calculate+average+color+of+image+in+python&aqs=chrome..69i57.7960j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=fastest+way+to+calculate+average+color+of+image+in+python&rlz=1C5CHFA_enUS863US865&oq=fastest+way+to+calculate+average+color+of+image+in+python&aqs=chrome..69i57.7960j0j7&sourceid=chrome&ie=UTF-8")'>fastest way to calculate average color of image in python</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot84.png' width='180' height='112'> </td></tr><tr><td><a href='https://towardsdatascience.com/finding-most-common-colors-in-python-47ea0767a06a' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://towardsdatascience.com/finding-most-common-colors-in-python-47ea0767a06a")'>Finding the Most Common Colors in Python | by M. Rake Linggar A. | Towards Data Science</a></td></tr></tbody></table></div>
</div>
</div>

<button type='button' class='collapsible'>main.py: Resize image to 1X1 pixel to see "average" pixel</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image


basewidth = 50
img = Image.open(target_photo)
wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)
image_matrix = img.load()
print(img.shape)



#img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image


basewidth = 50
img = Image.open(target_photo)
wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
#img = img.resize((basewidth, hsize), Image.ANTIALIAS)
img = img.resize((1, 1), Image.ANTIALIAS)

image_matrix = img.load()
width, height = img.size

for x in range(width):
    for y in range(height):
        pixel = image_matrix[x,y]
        print(pixel)



img.save("resized_image.jpg")' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region1')">def get_avg_pixel(img):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region26')">    img = scale_image_to_basewidth(img, basewidth=50)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region27')">    #loop through each pixel of the target image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region31')">def make_mosaic_avg(target_photo, photos_dir=Photos/, basewidth=50, pixelWidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region32')">    for y in range(height):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region35')">pixels_per_row = basewidth</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Calculate Average Pixel with Numpy average to compare runtime</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image


basewidth = 50
img = Image.open(target_photo)
wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
#img = img.resize((basewidth, hsize), Image.ANTIALIAS)
img = img.resize((1, 1), Image.ANTIALIAS)

image_matrix = img.load()
width, height = img.size

for x in range(width):
    for y in range(height):
        pixel = image_matrix[x,y]
        print(pixel)



img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np



basewidth = 50
img = Image.open(target_photo)
wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
#img = img.resize((basewidth, hsize), Image.ANTIALIAS)
#img = img.resize((50, 50), Image.ANTIALIAS)

image_matrix = img.load()
width, height = img.size

arr = []
for x in range(width):
    for y in range(height):
        pixel = image_matrix[x,y]
        #print(pixel)
        arr.append(list(pixel))

arr = np.array(arr)
print(arr.shape)
print(np.mean(arr, axis=1))


img.save("resized_image.jpg")' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region0')">from PIL import Image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region35')">pixels_per_row = basewidth</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Calculate Average Pixel with Numpy average to compare runtime</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np



basewidth = 50
img = Image.open(target_photo)
wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
#img = img.resize((basewidth, hsize), Image.ANTIALIAS)
#img = img.resize((50, 50), Image.ANTIALIAS)

image_matrix = img.load()
width, height = img.size

arr = []
for x in range(width):
    for y in range(height):
        pixel = image_matrix[x,y]
        #print(pixel)
        arr.append(list(pixel))

arr = np.array(arr)
print(arr.shape)
print(np.mean(arr, axis=1))


img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np



basewidth = 50
img = Image.open(target_photo)
wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
#img = img.resize((basewidth, hsize), Image.ANTIALIAS)
#img = img.resize((1, 1), Image.ANTIALIAS)

image_matrix = img.load()
width, height = img.size

arr = []
for x in range(width):
     for y in range(height):
         pixel = image_matrix[x,y]
         #print(pixel)
         arr.append(list(pixel))

# arr = np.array(arr)
print(np.mean(arr, axis=0))


img.save("resized_image.jpg")' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region0')">from PIL import Image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region35')">pixels_per_row = basewidth</li>
</ul>
</div></div><div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal15">
		<legend>Sub-goal</legend>
		<div>Get average pixel for each JPG file in folder</div>
	</fieldset>
<button type='button' class='collapsible'>main.py: Loop through photos in directory, calculate average pixel of each</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

photos_dir = "Photos/"
for filename in os.listdir(photos_dir):
     img = Image.open(photos_dir+filename)
     


img = Image.open(target_photo)
basewidth = 50


# wpercent = (basewidth / float(img.size[0]))
# hsize = int((float(img.size[1]) * float(wpercent)))
# img = img.resize((basewidth, hsize), Image.ANTIALIAS)



# image_matrix = img.load()
# width, height = img.size

# for x in range(width):
#      for y in range(height):
#          pixel = image_matrix[x,y]

# img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

photos_dir = "Photos/"
for filename in os.listdir(photos_dir):
    if filename.endswith(".jpg"):
        img = Image.open(photos_dir+filename)
        try:
            get_avg_pixel(img)
        except:
            print("Error:",filename)



img = Image.open(target_photo)
basewidth = 50


# wpercent = (basewidth / float(img.size[0]))
# hsize = int((float(img.size[1]) * float(wpercent)))
# img = img.resize((basewidth, hsize), Image.ANTIALIAS)



# image_matrix = img.load()
# width, height = img.size

# for x in range(width):
#      for y in range(height):
#          pixel = image_matrix[x,y]

# img.save("resized_image.jpg")' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region0')">from PIL import Image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region1')">def get_avg_pixel(img):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region2')">def get_file_avgPixelMap(file_image_map):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region3')">def get_file_image_map(photos_dir, width=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region9')">def scale_image_to_basewidth(img, basewidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region26')">    img = scale_image_to_basewidth(img, basewidth=50)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region27')">    #loop through each pixel of the target image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region31')">def make_mosaic_avg(target_photo, photos_dir=Photos/, basewidth=50, pixelWidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region32')">    for y in range(height):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region35')">pixels_per_row = basewidth</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region36')">target_photo = angie_flower.jpeg</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Dump pre-calculated average pixels to disk to test usage speed</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

photos_dir = "Photos/"
for filename in os.listdir(photos_dir):
    if filename.endswith(".jpg"):
        img = Image.open(photos_dir+filename)
        try:
            get_avg_pixel(img)
        except:
            print("Error:",filename)



img = Image.open(target_photo)
basewidth = 50


# wpercent = (basewidth / float(img.size[0]))
# hsize = int((float(img.size[1]) * float(wpercent)))
# img = img.resize((basewidth, hsize), Image.ANTIALIAS)



# image_matrix = img.load()
# width, height = img.size

# for x in range(width):
#      for y in range(height):
#          pixel = image_matrix[x,y]

# img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle


def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))
print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


# wpercent = (basewidth / float(img.size[0]))
# hsize = int((float(img.size[1]) * float(wpercent)))
# img = img.resize((basewidth, hsize), Image.ANTIALIAS)



# image_matrix = img.load()
# width, height = img.size

# for x in range(width):
#      for y in range(height):
#          pixel = image_matrix[x,y]

# img.save("resized_image.jpg")' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region2')">def get_file_avgPixelMap(file_image_map):</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Map average pixel values back to their respective filenames</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle


def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))
print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


# wpercent = (basewidth / float(img.size[0]))
# hsize = int((float(img.size[1]) * float(wpercent)))
# img = img.resize((basewidth, hsize), Image.ANTIALIAS)



# image_matrix = img.load()
# width, height = img.size

# for x in range(width):
#      for y in range(height):
#          pixel = image_matrix[x,y]

# img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle


def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    filename_map[avg_pixel_value] = filename


print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


# wpercent = (basewidth / float(img.size[0]))
# hsize = int((float(img.size[1]) * float(wpercent)))
# img = img.resize((basewidth, hsize), Image.ANTIALIAS)



# image_matrix = img.load()
# width, height = img.size

# for x in range(width):
#      for y in range(height):
#          pixel = image_matrix[x,y]

# img.save("resized_image.jpg")' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region7')">def get_pixel_files_map(pixel_map):</li>
</ul>
</div></div><div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal20">
		<legend>Sub-goal</legend>
		<div>For each pixel of target_photo, find photo with closest average pixel</div>
	</fieldset>
<button type='button' class='collapsible'>search: python vector similarity;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=python+pixel+similarity&rlz=1C5CHFA_enUS863US865&oq=python+pixel+similarity&aqs=chrome..69i57j0i22i30i625j0i390l4j69i60.2792j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+pixel+similarity&rlz=1C5CHFA_enUS863US865&oq=python+pixel+similarity&aqs=chrome..69i57j0i22i30i625j0i390l4j69i60.2792j0j7&sourceid=chrome&ie=UTF-8")'>python pixel similarity</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+vector+similarity&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVCnQ_ffL2i3FxVIHEMUOgPO0vf_w%3A1676498440662&ei=CFbtY43bJ_2hptQP-cWAqAs&ved=0ahUKEwiN_5Www5j9AhX9kIkEHfkiALUQ4dUDCBA&uact=5&oq=python+vector+similarity&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIJCAAQBxAeEPEEMgcIABANEIAEMggIABAIEAcQHjIICAAQCBAHEB4yCwgAEAgQBxAeEPEEMgsIABAIEAcQHhDxBDIJCAAQCBAeEPEEMgkIABAIEB4Q8QQyBQgAEIYDMgUIABCGAzoKCAAQRxDWBBCwAzoLCAAQCBAeEA0Q8QQ6CggAEAgQHhANEA9KBAhBGABKBAhGGABQ-whYsRFg2hJoAnABeACAAWeIAd0DkgEDNS4xmAEAoAEByAEIwAEB&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+vector+similarity&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVCnQ_ffL2i3FxVIHEMUOgPO0vf_w%3A1676498440662&ei=CFbtY43bJ_2hptQP-cWAqAs&ved=0ahUKEwiN_5Www5j9AhX9kIkEHfkiALUQ4dUDCBA&uact=5&oq=python+vector+similarity&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIJCAAQBxAeEPEEMgcIABANEIAEMggIABAIEAcQHjIICAAQCBAHEB4yCwgAEAgQBxAeEPEEMgsIABAIEAcQHhDxBDIJCAAQCBAeEPEEMgkIABAIEB4Q8QQyBQgAEIYDMgUIABCGAzoKCAAQRxDWBBCwAzoLCAAQCBAeEA0Q8QQ6CggAEAgQHhANEA9KBAhBGABKBAhGGABQ-whYsRFg2hJoAnABeACAAWeIAd0DkgEDNS4xmAEAoAEByAEIwAEB&sclient=gws-wiz-serp")'>python vector similarity</a></span></div><hr>
<div class='webImageLongRow'>
</div>
</div>

<button type='button' class='collapsible'>search: python kdtree example;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=scipy+spatial&rlz=1C5CHFA_enUS863US865&oq=scipy+spatial&aqs=chrome..69i57j0i512l9.2200j0j9&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=scipy+spatial&rlz=1C5CHFA_enUS863US865&oq=scipy+spatial&aqs=chrome..69i57j0i512l9.2200j0j9&sourceid=chrome&ie=UTF-8")'>scipy spatial</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot32.png' width='180' height='112'> </td></tr><tr><td><a href='https://docs.scipy.org/doc/scipy/reference/spatial.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://docs.scipy.org/doc/scipy/reference/spatial.html")'>Spatial algorithms and data structures (scipy.spatial)  SciPy v1.10.1 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot35.png' width='180' height='112'> </td></tr><tr><td><a href='https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.html#scipy.spatial.KDTree' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.html#scipy.spatial.KDTree")'>scipy.spatial.KDTree  SciPy v1.10.1 Manual</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+kdtree+example&rlz=1C5CHFA_enUS863US865&oq=python+KDTree+example&aqs=chrome.0.0i512j0i22i30i625j0i22i30j0i22i30i625j0i22i30l2j0i390l4.2374j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+kdtree+example&rlz=1C5CHFA_enUS863US865&oq=python+KDTree+example&aqs=chrome.0.0i512j0i22i30i625j0i22i30j0i22i30i625j0i22i30l2j0i390l4.2374j0j7&sourceid=chrome&ie=UTF-8")'>python kdtree example</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot83.png' width='180' height='112'> </td></tr><tr><td><a href='https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.query.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.query.html")'>scipy.spatial.KDTree.query  SciPy v1.10.1 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot35.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.html#scipy.spatial.KDTree' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.html#scipy.spatial.KDTree")'>scipy.spatial.KDTree  SciPy v1.10.1 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot36.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.query.html#scipy.spatial.KDTree.query' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.query.html#scipy.spatial.KDTree.query")'>scipy.spatial.KDTree.query  SciPy v1.10.1 Manual</a></td></tr></tbody></table></div>
</div>
</div>

<button type='button' class='collapsible'>main.py: Loop through target_photo's pixels and find the avg_pixel closest, then map back to the filename</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle


def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    filename_map[avg_pixel_value] = filename


print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


# wpercent = (basewidth / float(img.size[0]))
# hsize = int((float(img.size[1]) * float(wpercent)))
# img = img.resize((basewidth, hsize), Image.ANTIALIAS)



# image_matrix = img.load()
# width, height = img.size

# for x in range(width):
#      for y in range(height):
#          pixel = image_matrix[x,y]

# img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

# for x in range(width):
#      for y in range(height):
#         pixel = image_matrix[x,y]
#         nearest_neighbors = tree.query(pixel, k = 1)
#         pixel_index = nearest_neighbors[1]
#         neighbor_pixel = all_pixels[pixel_index]
#         closest_file = filename_map[neighbor_pixel]
#         #print(pixel, closest_file)
#         image_matrix[x,y] = neighbor_pixel
#         #img.putpixel((x,y), neighbor_pixel)

img.save("recolored_image.jpg")
#img.save("resized_image.jpg")' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region0')">from PIL import Image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region1')">def get_avg_pixel(img):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region7')">def get_pixel_files_map(pixel_map):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region8')">def get_all_avg_pixels_array(file_image_map):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region9')">def scale_image_to_basewidth(img, basewidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region26')">    img = scale_image_to_basewidth(img, basewidth=50)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region27')">    #loop through each pixel of the target image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region28')">            #generate subset of kmeans_dataframe that includes only the top-10 nearest neighbors</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region31')">def make_mosaic_avg(target_photo, photos_dir=Photos/, basewidth=50, pixelWidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region32')">    for y in range(height):</li>
</ul>
</div></div><div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal25">
		<legend>Sub-goal</legend>
		<div>Improve time it takes to loop through all images and find closest photo</div>
	</fieldset>
<button type='button' class='collapsible'>search: pil image draft;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=RGB+(177%2C+182%2C+182)&rlz=1C5CHFA_enUS863US865&oq=RGB+(177%2C+182%2C+182)&aqs=chrome..69i57j0i546l3j0i30i546.2345j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=RGB+(177%2C+182%2C+182)&rlz=1C5CHFA_enUS863US865&oq=RGB+(177%2C+182%2C+182)&aqs=chrome..69i57j0i546l3j0i30i546.2345j0j7&sourceid=chrome&ie=UTF-8")'>RGB (177, 182, 182)</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot37.png' width='180' height='112'> </td></tr><tr><td><a href='https://convertingcolors.com/rgb-color-177_182_182.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://convertingcolors.com/rgb-color-177_182_182.html")'>Converting Colors - RGB - 177, 182, 182</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=pil+update+pixel&rlz=1C5CHFA_enUS863US865&oq=pil+update+pixel&aqs=chrome..69i57j33i160l4.3009j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=pil+update+pixel&rlz=1C5CHFA_enUS863US865&oq=pil+update+pixel&aqs=chrome..69i57j33i160l4.3009j0j4&sourceid=chrome&ie=UTF-8")'>pil update pixel</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot38.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/36468530/changing-pixel-color-value-in-pil' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/36468530/changing-pixel-color-value-in-pil")'>python - Changing pixel color value in PIL - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot39.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.geeksforgeeks.org/python-pil-putpixel-method/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://www.geeksforgeeks.org/python-pil-putpixel-method/")'>Python PIL | putpixel() method - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=pil+append+images&rlz=1C5CHFA_enUS863US865&oq=pil+append+images&aqs=chrome..69i57j0i22i30i625l3j0i390l4.2623j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=pil+append+images&rlz=1C5CHFA_enUS863US865&oq=pil+append+images&aqs=chrome..69i57j0i22i30i625l3j0i390l4.2623j0j7&sourceid=chrome&ie=UTF-8")'>pil append images</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot82.png' width='180' height='112'> </td></tr><tr><td><a href='https://note.nkmk.me/en/python-pillow-concat-images/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://note.nkmk.me/en/python-pillow-concat-images/")'>Concatenate images with Python, Pillow | note.nkmk.me</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=pil+read+in+images+faster&rlz=1C5CHFA_enUS863US865&oq=pil+read+in+images+faster&aqs=chrome..69i57j33i160.3959j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=pil+read+in+images+faster&rlz=1C5CHFA_enUS863US865&oq=pil+read+in+images+faster&aqs=chrome..69i57j33i160.3959j0j7&sourceid=chrome&ie=UTF-8")'>pil read in images faster</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot43.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/57663734/how-to-speed-up-image-loading-in-pillow-python' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/57663734/how-to-speed-up-image-loading-in-pillow-python")'>How to speed up image loading in pillow (python)? - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=pil+image+draft&rlz=1C5CHFA_enUS863US865&oq=pil+image+draft&aqs=chrome..69i57j0i390l5.1921j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=pil+image+draft&rlz=1C5CHFA_enUS863US865&oq=pil+image+draft&aqs=chrome..69i57j0i390l5.1921j0j7&sourceid=chrome&ie=UTF-8")'>pil image draft</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot81.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.geeksforgeeks.org/python-pil-image-draft-method/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://www.geeksforgeeks.org/python-pil-image-draft-method/")'>Python PIL | Image.draft() method - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>
</div>

<button type='button' class='collapsible'>main.py: Add functions to concat images horizontally and vertically</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

for x in range(width):
     for y in range(height):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel]
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel

img.save("recolored_image.jpg")
#img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        print(closest_file)
        closest_img = Image.open(photos_dir+closest_file).resize((50, 50), Image.ANTIALIAS)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
        


img.save("recolored_image.jpg")
#img.save("resized_image.jpg")' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region5')">def get_concat_h(im1, im2):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region6')">def get_concat_v(im1, im2):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region27')">    #loop through each pixel of the target image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region28')">            #generate subset of kmeans_dataframe that includes only the top-10 nearest neighbors</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region32')">    for y in range(height):</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Create mapping from filename to image object so images aren't read in more than once</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        print(closest_file)
        closest_img = Image.open(photos_dir+closest_file).resize((50, 50), Image.ANTIALIAS)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
        


img.save("recolored_image.jpg")
#img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_all_images(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            file_image_map[filename] = img
    return file_image_map

file_image_map = get_all_images(photos_dir)
pickle.dump(file_image_map, open("file_image_map.pkl","wb"))

file_image_map = pickle.load(open("file_image_map.pkl","rb"))

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
        


img.save("recolored_image.jpg")
#img.save("resized_image.jpg")' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region3')">def get_file_image_map(photos_dir, width=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region4')">            file_image_map[filename] = img</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region24')">    #get dictionary mapping each filename to its respective image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region29')">            # pick a random image of the top 10 centroid matches</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Saving and loading filename to image map to disk to improve runtime</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_all_images(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            file_image_map[filename] = img
    return file_image_map

file_image_map = get_all_images(photos_dir)
pickle.dump(file_image_map, open("file_image_map.pkl","wb"))

file_image_map = pickle.load(open("file_image_map.pkl","rb"))

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
        


img.save("recolored_image.jpg")
#img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_all_images(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename).draft("RGB",(50,50))
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

print("generating map")
file_image_map = get_all_images(photos_dir)
print("map generated")
#pickle.dump(file_image_map, open("file_image_map.pkl","wb"))
print("pickled")

#file_image_map = pickle.load(open("file_image_map.pkl","rb"))

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        print(closest_file)
        closest_img = file_image_map[closest_file]
        #closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
        


img.save("recolored_image.jpg")
#img.save("resized_image.jpg")' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
</ul>
</div><button type='button' class='collapsible'>revisit: Python PIL | Image.draft() method - GeeksforGeeks;'</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot81.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.geeksforgeeks.org/python-pil-image-draft-method/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://www.geeksforgeeks.org/python-pil-image-draft-method/")'>Python PIL | Image.draft() method - GeeksforGeeks</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot45.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://note.nkmk.me/en/python-opencv-pillow-image-size/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://note.nkmk.me/en/python-opencv-pillow-image-size/")'>Get image size (width, height) with Python, OpenCV, Pillow (PIL) | note.nkmk.me</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot81.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.geeksforgeeks.org/python-pil-image-draft-method/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://www.geeksforgeeks.org/python-pil-image-draft-method/")'>Python PIL | Image.draft() method - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>
</div>

</div><div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal32">
		<legend>Sub-goal</legend>
		<div>Generating the first version of the mosaic and organize code</div>
	</fieldset>
<button type='button' class='collapsible'>main.py: Build mosaic by appending images for each pixel to a running image</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_all_images(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename).draft("RGB",(50,50))
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

print("generating map")
file_image_map = get_all_images(photos_dir)
print("map generated")
#pickle.dump(file_image_map, open("file_image_map.pkl","wb"))
print("pickled")

#file_image_map = pickle.load(open("file_image_map.pkl","rb"))

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        print(closest_file)
        closest_img = file_image_map[closest_file]
        #closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
        


img.save("recolored_image.jpg")
#img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_all_images(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst


print("generating map")
file_image_map = get_all_images(photos_dir)
print("map generated")
#pickle.dump(file_image_map, open("file_image_map.pkl","wb"))
print("pickled")

#file_image_map = pickle.load(open("file_image_map.pkl","rb"))

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = get_all_avg_pixels(photos_dir)#pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)


image_matrix = img.load()
width, height = img.size


for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region30')">            #add new image object running row image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region33')">                    window_x_min = max(0, x-min_array_distance_between_similar_photos)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region40')">img = make_mosaic_avg(target_photo, photos_dir, basewidth=basewidth, pixelWidth=pixelWidth)</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Clean up code by putting it into functions</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_all_images(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst


print("generating map")
file_image_map = get_all_images(photos_dir)
print("map generated")
#pickle.dump(file_image_map, open("file_image_map.pkl","wb"))
print("pickled")

#file_image_map = pickle.load(open("file_image_map.pkl","rb"))

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = get_all_avg_pixels(photos_dir)#pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)


image_matrix = img.load()
width, height = img.size


for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

print("generating map")
file_image_map = get_file_image_map(photos_dir)
print("map generated")
file_avgPixel_map = get_file_avgPixelMap(file_image_map)#pickle.load(open("photo_pixel_map.pkl", "rb"))
print("get_all_avg_pixels completed")


pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(pixel_files_map)

tree = KDTree(all_avg_pixels)


img = Image.open(target_photo)

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region3')">def get_file_image_map(photos_dir, width=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region7')">def get_pixel_files_map(pixel_map):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region8')">def get_all_avg_pixels_array(file_image_map):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region9')">def scale_image_to_basewidth(img, basewidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region24')">    #get dictionary mapping each filename to its respective image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region26')">    img = scale_image_to_basewidth(img, basewidth=50)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region28')">            #generate subset of kmeans_dataframe that includes only the top-10 nearest neighbors</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region31')">def make_mosaic_avg(target_photo, photos_dir=Photos/, basewidth=50, pixelWidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region32')">    for y in range(height):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region34')">basewidth = 60</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Functionalize get_file_avgPixelMap() to make code neater</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

print("generating map")
file_image_map = get_file_image_map(photos_dir)
print("map generated")
file_avgPixel_map = get_file_avgPixelMap(file_image_map)#pickle.load(open("photo_pixel_map.pkl", "rb"))
print("get_all_avg_pixels completed")


pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(pixel_files_map)

tree = KDTree(all_avg_pixels)


img = Image.open(target_photo)

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        img.draft("RGB", (1,1))
        try:
            pixel = get_avg_pixel(img)
            file_avgPixel_map[file] = pixel
        except:
            print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels



def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region2')">def get_file_avgPixelMap(file_image_map):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region11')">    Parameters:</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region20')">    file_index_map = {}</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region27')">    #loop through each pixel of the target image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region31')">def make_mosaic_avg(target_photo, photos_dir=Photos/, basewidth=50, pixelWidth=50):</li>
</ul>
</div></div><div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal37">
		<legend>Sub-goal</legend>
		<div>Now that something is working, investigate other ways of compiling mosaic to compare</div>
	</fieldset>
<button type='button' class='collapsible'>main.py: Testing the impact of pulling a random picture from the top-10 matches, instead of using the top match </button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        img.draft("RGB", (1,1))
        return img.load()[0,0]
        # try:
        #     pixel = get_avg_pixel(img)
        #     file_avgPixel_map[file] = pixel
        # except:
        #     print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels



def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "colorwheel.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
        print(pixel, neighbor_pixel)
        image_matrix[x,y] = np.mean([pixel, neighbor_pixel],axis=0)
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region0')">from PIL import Image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region27')">    #loop through each pixel of the target image</li>
</ul>
</div><button type='button' class='collapsible'>search: python find dominant color in image;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=color+wheel+jpg&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzXQu_fpTAkmqbBy3kVS2tJdbTBc7A:1676570731091&source=lnms&tbm=isch&sa=X&ved=2ahUKEwj8-PfW0Jr9AhVZkYkEHSkcBlgQ_AUoAXoECAEQAw&biw=1680&bih=914&dpr=1' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=color+wheel+jpg&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzXQu_fpTAkmqbBy3kVS2tJdbTBc7A:1676570731091&source=lnms&tbm=isch&sa=X&ved=2ahUKEwj8-PfW0Jr9AhVZkYkEHSkcBlgQ_AUoAXoECAEQAw&biw=1680&bih=914&dpr=1")'>color wheel jpg</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+convert+image+to+jpg&rlz=1C5CHFA_enUS863US865&oq=python+convert+image+to+jpg&aqs=chrome..69i57j0i22i30i625j0i22i30j0i22i30i625l7.3722j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+convert+image+to+jpg&rlz=1C5CHFA_enUS863US865&oq=python+convert+image+to+jpg&aqs=chrome..69i57j0i22i30i625j0i22i30j0i22i30i625l7.3722j0j7&sourceid=chrome&ie=UTF-8")'>python convert image to jpg</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot79.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.geeksforgeeks.org/convert-an-image-into-jpg-format-using-pillow-in-python/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://www.geeksforgeeks.org/convert-an-image-into-jpg-format-using-pillow-in-python/")'>Convert an image into jpg format using Pillow in Python - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+find+dominant+color+in+image&rlz=1C5CHFA_enUS863US865&oq=python+find+dominant+color+&aqs=chrome.0.0i512j69i57j0i22i30i625j0i15i22i30i625j0i22i30j0i390.3600j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+find+dominant+color+in+image&rlz=1C5CHFA_enUS863US865&oq=python+find+dominant+color+&aqs=chrome.0.0i512j69i57j0i22i30i625j0i15i22i30i625j0i22i30j0i390.3600j0j7&sourceid=chrome&ie=UTF-8")'>python find dominant color in image</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot50.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/3241929/python-find-dominant-most-common-color-in-an-image' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/3241929/python-find-dominant-most-common-color-in-an-image")'>Python - Find dominant/most common color in an image - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot78.png' width='180' height='112'> </td></tr><tr><td><a href='https://github.com/fengsp/color-thief-py' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://github.com/fengsp/color-thief-py")'>GitHub - fengsp/color-thief-py: Grabs the dominant color or a representative color palette from an image. Uses Python and Pillow.</a></td></tr></tbody></table></div>
</div>
</div>

</div><div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal41">
		<legend>Sub-goal</legend>
		<div>Use Kmeans to cluster pixels in an image into groups of colors</div>
	</fieldset>
<button type='button' class='collapsible'>search: kmeans pil image;'</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot78.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://github.com/fengsp/color-thief-py' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://github.com/fengsp/color-thief-py")'>GitHub - fengsp/color-thief-py: Grabs the dominant color or a representative color palette from an image. Uses Python and Pillow.</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot53.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/10016352/convert-numpy-array-to-tuple' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/10016352/convert-numpy-array-to-tuple")'>python - Convert numpy array to tuple - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot54.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.statology.org/numpy-array-to-int/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://www.statology.org/numpy-array-to-int/")'>How to Convert NumPy Array of Floats into Integers - Statology</a></td></tr></tbody></table></div>
<div class='title'><span><a href='https://www.google.com/search?q=python+blend+image+with+pixel+color&rlz=1C5CHFA_enUS863US865&oq=python+blend+image+with+pixel+color&aqs=chrome..69i57j33i160.8551j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+blend+image+with+pixel+color&rlz=1C5CHFA_enUS863US865&oq=python+blend+image+with+pixel+color&aqs=chrome..69i57j33i160.8551j0j4&sourceid=chrome&ie=UTF-8")'>python blend image with pixel color</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot77.png' width='180' height='112'> </td></tr><tr><td><a href='https://blog.finxter.com/five-useful-image-processing-techniques-in-python-using-opencv/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://blog.finxter.com/five-useful-image-processing-techniques-in-python-using-opencv/")'>Temporary Page</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot91.png' width='180' height='112'> </td></tr><tr><td><a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html")'>sklearn.cluster.KMeans  scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=kmeans+pil+image&rlz=1C5CHFA_enUS863US865&oq=kmeans+pil+image&aqs=chrome..69i57j0i22i30i625j0i390l4.2711j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=kmeans+pil+image&rlz=1C5CHFA_enUS863US865&oq=kmeans+pil+image&aqs=chrome..69i57j0i22i30i625j0i390l4.2711j0j7&sourceid=chrome&ie=UTF-8")'>kmeans pil image</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot57.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/69640278/how-to-usekmeans-parameter-in-pillow-image-quantize' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/69640278/how-to-usekmeans-parameter-in-pillow-image-quantize")'>python - How to use`kmeans` parameter in Pillow Image.quantize? - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot58.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.geeksforgeeks.org/python-pil-image-quantize-method/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://www.geeksforgeeks.org/python-pil-image-quantize-method/")'>Python PIL | Image.quantize() method - GeeksforGeeks</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot91.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html")'>sklearn.cluster.KMeans  scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot76.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/1109422/getting-list-of-pixel-values-from-pil' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/1109422/getting-list-of-pixel-values-from-pil")'>python - Getting list of pixel values from PIL - Stack Overflow</a></td></tr></tbody></table></div>
</div>
</div>

<button type='button' class='collapsible'>main.py: Print out pixel values for an image to investigate how to cluster the data using Kmeans</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "colorwheel.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
        print(pixel, neighbor_pixel)
        image_matrix[x,y] = np.mean([pixel, neighbor_pixel],axis=0)
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
pixels = img.getdata()
print(pixels)



exit()
file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region0')">from PIL import Image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region12')">        pixels = np.array(img.getdata())</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region35')">pixels_per_row = basewidth</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Cluster pixels of a given image, and print out centroid colors, and what percent of image falls into each</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
pixels = img.getdata()
print(pixels)



exit()
file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
img = scale_image_to_basewidth(img, basewidth=50)

pixels = np.array(img.getdata())

print(pixels.shape)

print("doing kmeans")

kmeans = KMeans(n_clusters=4).fit(pixels)
centroids = kmeans.cluster_centers_.astype(int)

print(len(pixels))
predictions = kmeans.predict(pixels)
centroid_indexes, counts = np.unique(predictions, return_counts = True)
percentages = counts / counts.sum()
for percent, centroid in zip(percentages, centroids):
    print(centroid, percent)


exit()
file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region0')">from PIL import Image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region12')">        pixels = np.array(img.getdata())</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region13')">        predictions = kmeans.predict(pixels)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region35')">pixels_per_row = basewidth</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region36')">target_photo = angie_flower.jpeg</li>
</ul>
</div><button type='button' class='collapsible'>search: python kmeans most dominant color;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=Segmentation+fault%3A+11&rlz=1C5CHFA_enUS863US865&oq=Segmentation+fault%3A+11&aqs=chrome..69i57.557j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=Segmentation+fault%3A+11&rlz=1C5CHFA_enUS863US865&oq=Segmentation+fault%3A+11&aqs=chrome..69i57.557j0j7&sourceid=chrome&ie=UTF-8")'>Segmentation fault: 11</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=Segmentation+fault%3A+11+every+other+time+i+run+python+kmeans&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVnkPFAxYemexMisFKcTdJTnmBo_A%3A1676578314267&ei=Co7uY6_nD8CnptQP6_2JgAs&ved=0ahUKEwivlPD27Jr9AhXAk4kEHet-ArAQ4dUDCBA&uact=5&oq=Segmentation+fault%3A+11+every+other+time+i+run+python+kmeans&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAE6CggAEEcQ1gQQsAM6BAgjECc6BAgAEEM6BQgAEIAEOgYIABAWEB46BQgAEIYDOggIIRAWEB4QHToFCCEQqwI6CwghEBYQHhDxBBAdSgQIQRgAULIEWN8_YKFKaAlwAXgAgAF6iAHXHJIBBTE4LjE5mAEAoAEByAEIwAEB&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=Segmentation+fault%3A+11+every+other+time+i+run+python+kmeans&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVnkPFAxYemexMisFKcTdJTnmBo_A%3A1676578314267&ei=Co7uY6_nD8CnptQP6_2JgAs&ved=0ahUKEwivlPD27Jr9AhXAk4kEHet-ArAQ4dUDCBA&uact=5&oq=Segmentation+fault%3A+11+every+other+time+i+run+python+kmeans&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAE6CggAEEcQ1gQQsAM6BAgjECc6BAgAEEM6BQgAEIAEOgYIABAWEB46BQgAEIYDOggIIRAWEB4QHToFCCEQqwI6CwghEBYQHhDxBBAdSgQIQRgAULIEWN8_YKFKaAlwAXgAgAF6iAHXHJIBBTE4LjE5mAEAoAEByAEIwAEB&sclient=gws-wiz-serp")'>Segmentation fault: 11 every other time i run python kmeans</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot74.png' width='180' height='112'> </td></tr><tr><td><a href='https://github.com/scikit-learn/scikit-learn/issues/23574' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://github.com/scikit-learn/scikit-learn/issues/23574")'>Segmentation Fault in KMeans on OSX · Issue #23574 · scikit-learn/scikit-learn · GitHub</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot62.png' width='180' height='112'> </td></tr><tr><td><a href='https://lightrun.com/answers/scikit-learn-scikit-learn-segmentation-fault-in-kmeans-on-osx' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://lightrun.com/answers/scikit-learn-scikit-learn-segmentation-fault-in-kmeans-on-osx")'>Segmentation Fault in KMeans on OSX</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=sklearn+kmeans+segfault&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzV8bsNpLGVAaej5lujlLmXPVvCBNw%3A1676578338813&ei=Io7uY6WJMaWbptQPgoGgiAo&ved=0ahUKEwilosqC7Zr9AhWljYkEHYIACKEQ4dUDCBA&uact=5&oq=sklearn+kmeans+segfault&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzILCAAQFhAeEPEEEAoyBQgAEIYDMgUIABCGAzIFCAAQhgMyBQgAEIYDOgcIIxCwAxAnOgoIABBHENYEELADOgQIIxAnOgQIABBDOgUIABCRAjoECC4QQzoRCC4QgwEQxwEQsQMQ0QMQgAQ6DgguEIAEELEDEMcBENEDOgsILhCABBDHARDRAzoKCAAQsQMQgwEQQzoLCAAQsQMQgwEQkQI6CwgAEIAEELEDEIMBOgoIABCABBAUEIcCOhAIABCABBAUEIcCELEDEIMBOgcIABCxAxBDOggIABCABBCxAzoFCAAQgAQ6CQgAEBYQHhDxBDoFCCEQoAFKBAhBGABQ_ghY7CVg5yZoBXAAeACAAW6IAcQQkgEEMjIuM5gBAKABAcgBCcABAQ&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=sklearn+kmeans+segfault&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzV8bsNpLGVAaej5lujlLmXPVvCBNw%3A1676578338813&ei=Io7uY6WJMaWbptQPgoGgiAo&ved=0ahUKEwilosqC7Zr9AhWljYkEHYIACKEQ4dUDCBA&uact=5&oq=sklearn+kmeans+segfault&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzILCAAQFhAeEPEEEAoyBQgAEIYDMgUIABCGAzIFCAAQhgMyBQgAEIYDOgcIIxCwAxAnOgoIABBHENYEELADOgQIIxAnOgQIABBDOgUIABCRAjoECC4QQzoRCC4QgwEQxwEQsQMQ0QMQgAQ6DgguEIAEELEDEMcBENEDOgsILhCABBDHARDRAzoKCAAQsQMQgwEQQzoLCAAQsQMQgwEQkQI6CwgAEIAEELEDEIMBOgoIABCABBAUEIcCOhAIABCABBAUEIcCELEDEIMBOgcIABCxAxBDOggIABCABBCxAzoFCAAQgAQ6CQgAEBYQHhDxBDoFCCEQoAFKBAhBGABQ_ghY7CVg5yZoBXAAeACAAW6IAcQQkgEEMjIuM5gBAKABAcgBCcABAQ&sclient=gws-wiz-serp")'>sklearn kmeans segfault</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot65.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/35973698/python-memory-error-for-kmeans-in-scikit-learn' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/35973698/python-memory-error-for-kmeans-in-scikit-learn")'>c++ - python memory error for kmeans in scikit-learn - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=mac+check+memory+usage&rlz=1C5CHFA_enUS863US865&oq=mac+check+memory+usage&aqs=chrome.0.0i512l4j0i22i30i625l6.2743j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=mac+check+memory+usage&rlz=1C5CHFA_enUS863US865&oq=mac+check+memory+usage&aqs=chrome.0.0i512l4j0i22i30i625l6.2743j0j4&sourceid=chrome&ie=UTF-8")'>mac check memory usage</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot64.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.google.com/search?q=sklearn+kmeans+segfault&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzV8bsNpLGVAaej5lujlLmXPVvCBNw%3A1676578338813&ei=Io7uY6WJMaWbptQPgoGgiAo&ved=0ahUKEwilosqC7Zr9AhWljYkEHYIACKEQ4dUDCBA&uact=5&oq=sklearn+kmeans+segfault&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzILCAAQFhAeEPEEEAoyBQgAEIYDMgUIABCGAzIFCAAQhgMyBQgAEIYDOgcIIxCwAxAnOgoIABBHENYEELADOgQIIxAnOgQIABBDOgUIABCRAjoECC4QQzoRCC4QgwEQxwEQsQMQ0QMQgAQ6DgguEIAEELEDEMcBENEDOgsILhCABBDHARDRAzoKCAAQsQMQgwEQQzoLCAAQsQMQgwEQkQI6CwgAEIAEELEDEIMBOgoIABCABBAUEIcCOhAIABCABBAUEIcCELEDEIMBOgcIABCxAxBDOggIABCABBCxAzoFCAAQgAQ6CQgAEBYQHhDxBDoFCCEQoAFKBAhBGABQ_ghY7CVg5yZoBXAAeACAAW6IAcQQkgEEMjIuM5gBAKABAcgBCcABAQ&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://www.google.com/search?q=sklearn+kmeans+segfault&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzV8bsNpLGVAaej5lujlLmXPVvCBNw%3A1676578338813&ei=Io7uY6WJMaWbptQPgoGgiAo&ved=0ahUKEwilosqC7Zr9AhWljYkEHYIACKEQ4dUDCBA&uact=5&oq=sklearn+kmeans+segfault&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzILCAAQFhAeEPEEEAoyBQgAEIYDMgUIABCGAzIFCAAQhgMyBQgAEIYDOgcIIxCwAxAnOgoIABBHENYEELADOgQIIxAnOgQIABBDOgUIABCRAjoECC4QQzoRCC4QgwEQxwEQsQMQ0QMQgAQ6DgguEIAEELEDEMcBENEDOgsILhCABBDHARDRAzoKCAAQsQMQgwEQQzoLCAAQsQMQgwEQkQI6CwgAEIAEELEDEIMBOgoIABCABBAUEIcCOhAIABCABBAUEIcCELEDEIMBOgcIABCxAxBDOggIABCABBCxAzoFCAAQgAQ6CQgAEBYQHhDxBDoFCCEQoAFKBAhBGABQ_ghY7CVg5yZoBXAAeACAAW6IAcQQkgEEMjIuM5gBAKABAcgBCcABAQ&sclient=gws-wiz-serp")'>sklearn kmeans segfault</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot65.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://stackoverflow.com/questions/35973698/python-memory-error-for-kmeans-in-scikit-learn' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://stackoverflow.com/questions/35973698/python-memory-error-for-kmeans-in-scikit-learn")'>c++ - python memory error for kmeans in scikit-learn - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot74.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://github.com/scikit-learn/scikit-learn/issues/23574' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://github.com/scikit-learn/scikit-learn/issues/23574")'>Segmentation Fault in KMeans on OSX · Issue #23574 · scikit-learn/scikit-learn · GitHub</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+kmeans+most+dominant+color&rlz=1C5CHFA_enUS863US865&oq=python+kmeans+most+dominant+color&aqs=chrome..69i57j33i160.5078j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+kmeans+most+dominant+color&rlz=1C5CHFA_enUS863US865&oq=python+kmeans+most+dominant+color&aqs=chrome..69i57j33i160.5078j0j7&sourceid=chrome&ie=UTF-8")'>python kmeans most dominant color</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot71.png' width='180' height='112'> </td></tr><tr><td><a href='https://medium.com/buzzrobot/dominant-colors-in-an-image-using-k-means-clustering-3c7af4622036' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://medium.com/buzzrobot/dominant-colors-in-an-image-using-k-means-clustering-3c7af4622036")'>Dominant colors in an image using k-means clustering | by Shivam Thakkar | buZZrobot | Medium</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot91.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html")'>sklearn.cluster.KMeans  scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
</div>
</div>

<button type='button' class='collapsible'>search: rgb 111  58  51;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=159+155+145&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVeJzMui1qfxImi4KPl4_em2DrXIg%3A1676579777063&ei=wZPuY7y-A6K6qtsPz5askA0&ved=0ahUKEwj8orKw8pr9AhUinWoFHU8LC9IQ4dUDCBA&uact=5&oq=159+155+145&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzoKCAAQRxDWBBCwA0oECEEYAFD7DFj7DGCgEWgDcAF4AIABUYgBUZIBATGYAQCgAQKgAQHIAQXAAQE&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=159+155+145&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVeJzMui1qfxImi4KPl4_em2DrXIg%3A1676579777063&ei=wZPuY7y-A6K6qtsPz5askA0&ved=0ahUKEwj8orKw8pr9AhUinWoFHU8LC9IQ4dUDCBA&uact=5&oq=159+155+145&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzoKCAAQRxDWBBCwA0oECEEYAFD7DFj7DGCgEWgDcAF4AIABUYgBUZIBATGYAQCgAQKgAQHIAQXAAQE&sclient=gws-wiz-serp")'>159 155 145</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=rgb+159+155+145&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVTW6tdbpkulDuxBxJljMjHFCScyQ%3A1676579826081&ei=8pPuY_GsBLqeqtsP0uSO-AY&ved=0ahUKEwjx7eHH8pr9AhU6j2oFHVKyA28Q4dUDCBA&uact=5&oq=rgb+159+155+145&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCAAQogQyBQgAEKIEMgUIABCiBDIFCAAQogQ6BwgAEB4QogRKBAhBGAFQ-gNYgglg0gxoAXAAeACAAVeIAc0CkgEBNJgBAKABAcABAQ&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=rgb+159+155+145&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVTW6tdbpkulDuxBxJljMjHFCScyQ%3A1676579826081&ei=8pPuY_GsBLqeqtsP0uSO-AY&ved=0ahUKEwjx7eHH8pr9AhU6j2oFHVKyA28Q4dUDCBA&uact=5&oq=rgb+159+155+145&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCAAQogQyBQgAEKIEMgUIABCiBDIFCAAQogQ6BwgAEB4QogRKBAhBGAFQ-gNYgglg0gxoAXAAeACAAVeIAc0CkgEBNJgBAKABAcABAQ&sclient=gws-wiz-serp")'>rgb 159 155 145</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=rgb+75+102++69&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVPEpL8emeklswriOwzmCxu7RgTDQ%3A1676579834540&ei=-pPuY8TOIKmxqtsPr--i0Ak&ved=0ahUKEwjEs-bL8pr9AhWpmGoFHa-3CJoQ4dUDCBA&uact=5&oq=rgb+75+102++69&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCAAQogQyBwgAEB4QogQyBQgAEKIEOgoIABBHENYEELADOgQIIxAnOgUIABCRAjoECAAQQzoICC4Q1AIQkQI6CAguELEDEIMBOgUIABCABDoECAAQAzoHCAAQsQMQQzoKCAAQsQMQgwEQQzoRCC4QgAQQsQMQgwEQxwEQ0QM6DQgAEIAEEBQQhwIQsQM6CAgAEIAEELEDOgsIABCABBCxAxCDAUoECEEYAFDGC1iTE2CTFmgDcAF4AIABbIgB6gOSAQMzLjKYAQCgAQGgAQLIAQbAAQE&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=rgb+75+102++69&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVPEpL8emeklswriOwzmCxu7RgTDQ%3A1676579834540&ei=-pPuY8TOIKmxqtsPr--i0Ak&ved=0ahUKEwjEs-bL8pr9AhWpmGoFHa-3CJoQ4dUDCBA&uact=5&oq=rgb+75+102++69&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCAAQogQyBwgAEB4QogQyBQgAEKIEOgoIABBHENYEELADOgQIIxAnOgUIABCRAjoECAAQQzoICC4Q1AIQkQI6CAguELEDEIMBOgUIABCABDoECAAQAzoHCAAQsQMQQzoKCAAQsQMQgwEQQzoRCC4QgAQQsQMQgwEQxwEQ0QM6DQgAEIAEEBQQhwIQsQM6CAgAEIAEELEDOgsIABCABBCxAxCDAUoECEEYAFDGC1iTE2CTFmgDcAF4AIABbIgB6gOSAQMzLjKYAQCgAQGgAQLIAQbAAQE&sclient=gws-wiz-serp")'>rgb 75 102  69</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=rgb+111++58++51&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzUFwV4hlzPp7uNBMTQZlti5SouhDg%3A1676580106321&ei=CpXuY_qUE6u1ptQPzfK_8Ak&ved=0ahUKEwj6wbLN85r9AhWrmokEHU35D54Q4dUDCBA&uact=5&oq=rgb+111++58++51&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCAAQogQyCggAEPEEEB4QogQyBQgAEKIEMgUIABCiBDoKCAAQRxDWBBCwA0oECEEYAFC-BVi-BWC8B2gBcAB4AIABc4gBc5IBAzAuMZgBAKABAqABAcgBB8ABAQ&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=rgb+111++58++51&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzUFwV4hlzPp7uNBMTQZlti5SouhDg%3A1676580106321&ei=CpXuY_qUE6u1ptQPzfK_8Ak&ved=0ahUKEwj6wbLN85r9AhWrmokEHU35D54Q4dUDCBA&uact=5&oq=rgb+111++58++51&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCAAQogQyCggAEPEEEB4QogQyBQgAEKIEMgUIABCiBDoKCAAQRxDWBBCwA0oECEEYAFC-BVi-BWC8B2gBcAB4AIABc4gBc5IBAzAuMZgBAKABAqABAcgBB8ABAQ&sclient=gws-wiz-serp")'>rgb 111  58  51</a></span></div><hr>
<div class='webImageLongRow'>
</div>
</div>

<button type='button' class='collapsible'>revisit: Dominant colors in an image using k-means clustering | by Shivam Thakkar | buZZrobot | Medium;'</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot91.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html")'>sklearn.cluster.KMeans  scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot71.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://medium.com/buzzrobot/dominant-colors-in-an-image-using-k-means-clustering-3c7af4622036' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://medium.com/buzzrobot/dominant-colors-in-an-image-using-k-means-clustering-3c7af4622036")'>Dominant colors in an image using k-means clustering | by Shivam Thakkar | buZZrobot | Medium</a></td></tr></tbody></table></div>
</div>
</div>

<button type='button' class='collapsible'>search: python show color;'</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot71.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://medium.com/buzzrobot/dominant-colors-in-an-image-using-k-means-clustering-3c7af4622036' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://medium.com/buzzrobot/dominant-colors-in-an-image-using-k-means-clustering-3c7af4622036")'>Dominant colors in an image using k-means clustering | by Shivam Thakkar | buZZrobot | Medium</a></td></tr></tbody></table></div>
<div class='title'><span><a href='https://www.google.com/search?q=python+show+color&rlz=1C5CHFA_enUS863US865&oq=python+show+color&aqs=chrome..69i57j0i512l2j0i22i30i625l7.2817j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+show+color&rlz=1C5CHFA_enUS863US865&oq=python+show+color&aqs=chrome..69i57j0i512l2j0i22i30i625l7.2817j0j4&sourceid=chrome&ie=UTF-8")'>python show color</a></span></div><hr>
<div class='webImageLongRow'>
</div>
</div>

<button type='button' class='collapsible'>search: rgb 105 112  7;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=rgb+211+169+13&rlz=1C5CHFA_enUS863US865&oq=rgb+211+169++13&aqs=chrome..69i57j0i30i546j0i546.1601j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=rgb+211+169+13&rlz=1C5CHFA_enUS863US865&oq=rgb+211+169++13&aqs=chrome..69i57j0i30i546j0i546.1601j0j7&sourceid=chrome&ie=UTF-8")'>rgb 211 169 13</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=rgb+105+112++7&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVnN2KhHjxdmcXCmP6QocV_S2a2KA%3A1676580479854&ei=f5buY8rkM4alptQPgOyD8Ag&ved=0ahUKEwiKoMH_9Jr9AhWGkokEHQD2AI4Q4dUDCBA&uact=5&oq=rgb+105+112++7&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQqwIyDQghEBYQHhAPEPEEEB06CggAEEcQ1gQQsANKBAhBGABQ4wVY4wVgvQhoAXABeACAAWaIAWaSAQMwLjGYAQCgAQKgAQHIAQbAAQE&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=rgb+105+112++7&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVnN2KhHjxdmcXCmP6QocV_S2a2KA%3A1676580479854&ei=f5buY8rkM4alptQPgOyD8Ag&ved=0ahUKEwiKoMH_9Jr9AhWGkokEHQD2AI4Q4dUDCBA&uact=5&oq=rgb+105+112++7&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQqwIyDQghEBYQHhAPEPEEEB06CggAEEcQ1gQQsANKBAhBGABQ4wVY4wVgvQhoAXABeACAAWaIAWaSAQMwLjGYAQCgAQKgAQHIAQbAAQE&sclient=gws-wiz-serp")'>rgb 105 112  7</a></span></div><hr>
<div class='webImageLongRow'>
</div>
</div>

</div><div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal51">
		<legend>Sub-goal</legend>
		<div>Find the percent of an image's pixels that falls into a given cluster</div>
	</fieldset>
<button type='button' class='collapsible'>search: kmeans number in cluster;'</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot74.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://github.com/scikit-learn/scikit-learn/issues/23574' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://github.com/scikit-learn/scikit-learn/issues/23574")'>Segmentation Fault in KMeans on OSX · Issue #23574 · scikit-learn/scikit-learn · GitHub</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot91.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html")'>sklearn.cluster.KMeans  scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
<div class='title'><span><a href='https://www.google.com/search?q=kmeans+number+in+cluster&rlz=1C5CHFA_enUS863US865&oq=kmeans+number+in+cluster&aqs=chrome..69i57j0i22i30i625j0i22i30j0i22i30i625j0i390l3.3849j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=kmeans+number+in+cluster&rlz=1C5CHFA_enUS863US865&oq=kmeans+number+in+cluster&aqs=chrome..69i57j0i22i30i625j0i22i30j0i22i30i625j0i390l3.3849j0j7&sourceid=chrome&ie=UTF-8")'>kmeans number in cluster</a></span></div><hr>
<div class='webImageLongRow'>
</div>
</div>

<button type='button' class='collapsible'>revisit: Convert an image into jpg format using Pillow in Python - GeeksforGeeks;'</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot78.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://github.com/fengsp/color-thief-py' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://github.com/fengsp/color-thief-py")'>GitHub - fengsp/color-thief-py: Grabs the dominant color or a representative color palette from an image. Uses Python and Pillow.</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot79.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.geeksforgeeks.org/convert-an-image-into-jpg-format-using-pillow-in-python/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://www.geeksforgeeks.org/convert-an-image-into-jpg-format-using-pillow-in-python/")'>Convert an image into jpg format using Pillow in Python - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>
</div>

<button type='button' class='collapsible'>search: k means predict probability sklearn;'</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot84.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://towardsdatascience.com/finding-most-common-colors-in-python-47ea0767a06a' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://towardsdatascience.com/finding-most-common-colors-in-python-47ea0767a06a")'>Finding the Most Common Colors in Python | by M. Rake Linggar A. | Towards Data Science</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot85.png' width='180' height='112'> </td></tr><tr><td><a href='https://scikit-learn.org/stable/modules/clustering.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://scikit-learn.org/stable/modules/clustering.html")'>2.3. Clustering  scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot86.png' width='180' height='112'> </td></tr><tr><td><a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.OPTICS.html#sklearn.cluster.OPTICS' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.OPTICS.html#sklearn.cluster.OPTICS")'>sklearn.cluster.OPTICS  scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
<div class='title'><span><a href='https://www.google.com/search?q=best+clustering+algorithm+for+pixel+data&rlz=1C5CHFA_enUS863US865&oq=best+clustering+algorithm+for+pixel+data&aqs=chrome..69i57j33i160l4.4872j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=best+clustering+algorithm+for+pixel+data&rlz=1C5CHFA_enUS863US865&oq=best+clustering+algorithm+for+pixel+data&aqs=chrome..69i57j33i160l4.4872j0j4&sourceid=chrome&ie=UTF-8")'>best clustering algorithm for pixel data</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot92.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.google.com/search?q=kmeans+number+in+cluster&rlz=1C5CHFA_enUS863US865&oq=kmeans+number+in+cluster&aqs=chrome..69i57j0i22i30i625j0i22i30j0i22i30i625j0i390l3.3849j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://www.google.com/search?q=kmeans+number+in+cluster&rlz=1C5CHFA_enUS863US865&oq=kmeans+number+in+cluster&aqs=chrome..69i57j0i22i30i625j0i22i30j0i22i30i625j0i390l3.3849j0j7&sourceid=chrome&ie=UTF-8")'>kmeans number in cluster</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot91.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html")'>sklearn.cluster.KMeans  scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=k+means+predict+probability&rlz=1C5CHFA_enUS863US865&oq=k+means+predict+probability&aqs=chrome..69i57j33i160j33i299l2j33i22i29i30.2984j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=k+means+predict+probability&rlz=1C5CHFA_enUS863US865&oq=k+means+predict+probability&aqs=chrome..69i57j33i160j33i299l2j33i22i29i30.2984j0j7&sourceid=chrome&ie=UTF-8")'>k means predict probability</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot89.png' width='180' height='112'> </td></tr><tr><td><a href='https://datascience.stackexchange.com/questions/14435/how-to-get-the-probability-of-belonging-to-clusters-for-k-means' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://datascience.stackexchange.com/questions/14435/how-to-get-the-probability-of-belonging-to-clusters-for-k-means")'>python - How to get the probability of belonging to clusters for k-means? - Data Science Stack Exchange</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=k+means+predict+probability+sklearn&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVCEg8BXyZmHbKt1guKLJIskG0BPQ%3A1676582097169&ei=0ZzuY7LrCY6bptQPrOOZ-Ao&ved=0ahUKEwjyl9qC-5r9AhWOjYkEHaxxBq8Q4dUDCBA&uact=5&oq=k+means+predict+probability+sklearn&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAE6CggAEEcQ1gQQsAM6BQghEKsCOggIIRAWEB4QHToKCCEQFhAeEA8QHToLCCEQFhAeEPEEEB1KBAhBGABQ6QJYmwhg4AhoAXAAeACAAZEBiAGkBpIBAzIuNZgBAKABAcgBCMABAQ&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=k+means+predict+probability+sklearn&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVCEg8BXyZmHbKt1guKLJIskG0BPQ%3A1676582097169&ei=0ZzuY7LrCY6bptQPrOOZ-Ao&ved=0ahUKEwjyl9qC-5r9AhWOjYkEHaxxBq8Q4dUDCBA&uact=5&oq=k+means+predict+probability+sklearn&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAE6CggAEEcQ1gQQsAM6BQghEKsCOggIIRAWEB4QHToKCCEQFhAeEA8QHToLCCEQFhAeEPEEEB1KBAhBGABQ6QJYmwhg4AhoAXAAeACAAZEBiAGkBpIBAzIuNZgBAKABAcgBCMABAQ&sclient=gws-wiz-serp")'>k means predict probability sklearn</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot91.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html")'>sklearn.cluster.KMeans  scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
</div>
</div>

<button type='button' class='collapsible'>main.py: Create a pandas dataframe for one image that includes a list of all pixel colors and their respective clusters</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
img = scale_image_to_basewidth(img, basewidth=50)

pixels = np.array(img.getdata())

print(pixels.shape)

print("doing kmeans")

kmeans = KMeans(n_clusters=4).fit(pixels)
centroids = kmeans.cluster_centers_.astype(int)

print(len(pixels))
predictions = kmeans.predict(pixels)
centroid_indexes, counts = np.unique(predictions, return_counts = True)
percentages = counts / counts.sum()
for percent, centroid in zip(percentages, centroids):
    print(centroid, percent)


exit()
file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
img = scale_image_to_basewidth(img, basewidth=50)

def get_dataframe_image(img):
    pixels = np.array(img.getdata())
    kmeans = KMeans(n_clusters=4).fit(pixels)
    centroids = kmeans.cluster_centers_.astype(int)
    table_columns = ["filename","centroid","percent"]

    all_rows = []

    predictions = kmeans.predict(pixels)
    centroid_indexes, counts = np.unique(predictions, return_counts = True)
    percentages = counts / counts.sum()
    for percent, centroid in zip(percentages, centroids):
        #skip if percent < threshold
        print(tuple(centroid), percent)
        all_rows.append([target_photo, tuple(centroid), percent])

    df = pd.DataFrame(all_rows, columns=table_columns)
    return df

print(get_dataframe_image(img))


exit()
file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region0')">from PIL import Image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region11')">    Parameters:</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region13')">        predictions = kmeans.predict(pixels)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region35')">pixels_per_row = basewidth</li>
</ul>
</div><button type='button' class='collapsible'>search: pandas column of tuples becomes string;'</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot91.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html")'>sklearn.cluster.KMeans  scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot92.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.google.com/search?q=kmeans+number+in+cluster&rlz=1C5CHFA_enUS863US865&oq=kmeans+number+in+cluster&aqs=chrome..69i57j0i22i30i625j0i22i30j0i22i30i625j0i390l3.3849j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://www.google.com/search?q=kmeans+number+in+cluster&rlz=1C5CHFA_enUS863US865&oq=kmeans+number+in+cluster&aqs=chrome..69i57j0i22i30i625j0i22i30j0i22i30i625j0i390l3.3849j0j7&sourceid=chrome&ie=UTF-8")'>kmeans number in cluster</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot93.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/61589488/convert-a-column-in-a-dataframe-from-type-string-to-tuple' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/61589488/convert-a-column-in-a-dataframe-from-type-string-to-tuple")'>python - Convert a column in a dataframe from type string to tuple - Stack Overflow</a></td></tr></tbody></table></div>
<div class='title'><span><a href='https://www.google.com/search?q=pandas+string+to+tuple&rlz=1C5CHFA_enUS863US865&oq=pandas+string+to+tuple&aqs=chrome..69i57j0i22i30i625l6j0i22i30l2j0i22i30i625.2524j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=pandas+string+to+tuple&rlz=1C5CHFA_enUS863US865&oq=pandas+string+to+tuple&aqs=chrome..69i57j0i22i30i625l6j0i22i30l2j0i22i30i625.2524j0j7&sourceid=chrome&ie=UTF-8")'>pandas string to tuple</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot94.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.geeksforgeeks.org/python-convert-string-to-tuple/' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://www.geeksforgeeks.org/python-convert-string-to-tuple/")'>Python | Convert String to Tuple - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=pandas+column+of+tuples+becomes+string&rlz=1C5CHFA_enUS863US865&oq=pandas+column+of+tuples+becomes+string&aqs=chrome..69i57j33i160.6440j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=pandas+column+of+tuples+becomes+string&rlz=1C5CHFA_enUS863US865&oq=pandas+column+of+tuples+becomes+string&aqs=chrome..69i57j33i160.6440j0j4&sourceid=chrome&ie=UTF-8")'>pandas column of tuples becomes string</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot95.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/65409122/python-pandas-convert-a-column-of-tuples-to-string-column' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/65409122/python-pandas-convert-a-column-of-tuples-to-string-column")'>python pandas - Convert a column of tuples to string column - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot96.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.google.com/search?q=pandas+column+of+tuples+becomes+string&rlz=1C5CHFA_enUS863US865&oq=pandas+column+of+tuples+becomes+string&aqs=chrome..69i57j33i160.6440j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://www.google.com/search?q=pandas+column+of+tuples+becomes+string&rlz=1C5CHFA_enUS863US865&oq=pandas+column+of+tuples+becomes+string&aqs=chrome..69i57j33i160.6440j0j4&sourceid=chrome&ie=UTF-8")'>pandas column of tuples becomes string</a></td></tr></tbody></table></div>
</div>
</div>

<button type='button' class='collapsible'>main.py: Create pandas dataframe that includes pixels and their clusters for all images, and save to a csv file</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
img = scale_image_to_basewidth(img, basewidth=50)

def get_dataframe_image(img):
    pixels = np.array(img.getdata())
    kmeans = KMeans(n_clusters=4).fit(pixels)
    centroids = kmeans.cluster_centers_.astype(int)
    table_columns = ["filename","centroid","percent"]

    all_rows = []

    predictions = kmeans.predict(pixels)
    centroid_indexes, counts = np.unique(predictions, return_counts = True)
    percentages = counts / counts.sum()
    for percent, centroid in zip(percentages, centroids):
        #skip if percent < threshold
        print(tuple(centroid), percent)
        all_rows.append([target_photo, tuple(centroid), percent])

    df = pd.DataFrame(all_rows, columns=table_columns)
    return df

print(get_dataframe_image(img))


exit()
file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
img = scale_image_to_basewidth(img, basewidth=50)


def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)


file_image_map = get_file_image_map(photos_dir)
print("here")
df = get_kmeans_dataframe_all_photos(file_image_map)
print("done")
df.to_csv("kmean_data_all_photos.csv",index=False)
print(df)
exit()

file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region10')">def get_kmeans_dataframe_all_photos(file_image_map):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region13')">        predictions = kmeans.predict(pixels)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region24')">    #get dictionary mapping each filename to its respective image</li>
</ul>
</div></div><div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal59">
		<legend>Sub-goal</legend>
		<div>Use Kmeans clusters for each image to determine which images have clusters similar to a given pixel</div>
	</fieldset>
<button type='button' class='collapsible'>main.py: Load pandas kmeans dataframe from CSV and create mosaic using images with similar centroids as a given target_pixel</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
img = scale_image_to_basewidth(img, basewidth=50)


def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)


file_image_map = get_file_image_map(photos_dir)
print("here")
df = get_kmeans_dataframe_all_photos(file_image_map)
print("done")
df.to_csv("kmean_data_all_photos.csv",index=False)
print(df)
exit()

file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)


file_image_map = get_file_image_map(photos_dir)

first_run = False

if first_run:
    kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
    kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
else:
    kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")


print(kmeans_dataframe)
all_centroids = kmeans_dataframe["centroid"].values.astype(tuple)
print(tuple("(1,2)"))
#print(all_centroids)

nearest_neighbors_tree = KDTree(all_centroids)
img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_centroids[pixel_index]
        closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]["filename"].values
        closest_file = closest_files[0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

"""
#if pixel average method:

file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)
"""




column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region24')">    #get dictionary mapping each filename to its respective image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region25')">    #get list of all centroids</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region28')">            #generate subset of kmeans_dataframe that includes only the top-10 nearest neighbors</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Handle parsing what's loaded from CSV from string format to tuple</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)


file_image_map = get_file_image_map(photos_dir)

first_run = False

if first_run:
    kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
    kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
else:
    kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")


print(kmeans_dataframe)
all_centroids = kmeans_dataframe["centroid"].values.astype(tuple)
print(tuple("(1,2)"))
#print(all_centroids)

nearest_neighbors_tree = KDTree(all_centroids)
img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_centroids[pixel_index]
        closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]["filename"].values
        closest_file = closest_files[0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

"""
#if pixel average method:

file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)
"""




column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

file_image_map = get_file_image_map(photos_dir)

first_run = False

if first_run:
    kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
    kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
else:
    kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
    kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

print(kmeans_dataframe)

all_centroids = kmeans_dataframe["centroid"].tolist()
print(all_centroids)

for c in all_centroids:
    print(sum(c))

nearest_neighbors_tree = KDTree(all_centroids)
img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][0]#[random.randint(0, 9)]
        neighbor_pixel = all_centroids[pixel_index]
        closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]["filename"].values
        closest_file = closest_files[0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

"""
#if pixel average method:

file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)
"""




column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region14')">def string_to_tuple(s):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region24')">    #get dictionary mapping each filename to its respective image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region25')">    #get list of all centroids</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region28')">            #generate subset of kmeans_dataframe that includes only the top-10 nearest neighbors</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Find the 10 images with a cluster centroid closest to a target_pixel, and then choose the one that has the largest amount in that cluster</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

file_image_map = get_file_image_map(photos_dir)

first_run = False

if first_run:
    kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
    kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
else:
    kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
    kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

print(kmeans_dataframe)

all_centroids = kmeans_dataframe["centroid"].tolist()
print(all_centroids)

for c in all_centroids:
    print(sum(c))

nearest_neighbors_tree = KDTree(all_centroids)
img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][0]#[random.randint(0, 9)]
        neighbor_pixel = all_centroids[pixel_index]
        closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]["filename"].values
        closest_file = closest_files[0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

"""
#if pixel average method:

file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)
"""




column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

file_image_map = get_file_image_map(photos_dir)

first_run = False

if first_run:
    kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
    kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
else:
    kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
    kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

print(kmeans_dataframe)

all_centroids = kmeans_dataframe["centroid"].tolist()
print(all_centroids)

for c in all_centroids:
    print(sum(c))

nearest_neighbors_tree = KDTree(all_centroids)
img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        closest_files_dfs = []
        for i in range(10):    
            pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
            neighbor_pixel = all_centroids[pixel_index]
            closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
            closest_files_dfs.append(closest_files)
        closest_files_df = pd.concat(closest_files_dfs)
        closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[0]
        #closest_file = closest_files[0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

"""
#if pixel average method:

file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)
"""




column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region28')">            #generate subset of kmeans_dataframe that includes only the top-10 nearest neighbors</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region29')">            # pick a random image of the top 10 centroid matches</li>
</ul>
</div></div><div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal64">
		<legend>Sub-goal</legend>
		<div>Detect if two images are duplicates or near-identical</div>
	</fieldset>
<button type='button' class='collapsible'>main.py: Load Two images for similarity comparison</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


mosaic_image = make_mosaic_avg(target_photo, photos_dir)
mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


img = Image.open("target_angie.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)
print(arr.shape)

img2 = Image.open("target_photo.jpg")
img2.draft("RGB",(50,50))
image_matrix2 = img2.load()


#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region21')">def make_mosaic_kmeans(target_photo, photos_dir=Photos/, first_run = False):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region29')">            # pick a random image of the top 10 centroid matches</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region30')">            #add new image object running row image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region31')">def make_mosaic_avg(target_photo, photos_dir=Photos/, basewidth=50, pixelWidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region33')">                    window_x_min = max(0, x-min_array_distance_between_similar_photos)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region38')">    img = Image.open(angie_bed1.jpg)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region40')">img = make_mosaic_avg(target_photo, photos_dir, basewidth=basewidth, pixelWidth=pixelWidth)</li>
</ul>
</div><button type='button' class='collapsible'>search: python jpg similarity;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=python+image+similarity&rlz=1C5CHFA_enUS863US865&oq=python+image+simila&aqs=chrome.0.0i512j69i57j0i512l4j0i22i30i625l4.3911j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+image+similarity&rlz=1C5CHFA_enUS863US865&oq=python+image+simila&aqs=chrome.0.0i512j69i57j0i512l4j0i22i30i625l4.3911j0j7&sourceid=chrome&ie=UTF-8")'>python image similarity</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot97.png' width='180' height='112'> </td></tr><tr><td><a href='https://betterprogramming.pub/how-to-measure-image-similarities-in-python-12f1cb2b7281' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://betterprogramming.pub/how-to-measure-image-similarities-in-python-12f1cb2b7281")'>How To Measure Image Similarities In Python | Better Programming</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot98.png' width='180' height='112'> </td></tr><tr><td><a href='https://towardsdatascience.com/measuring-similarity-in-two-images-using-python-b72233eb53c6' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://towardsdatascience.com/measuring-similarity-in-two-images-using-python-b72233eb53c6")'>Measuring similarity in two images using Python | by Param Raval | Towards Data Science</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+image+similarity+pil&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzUfhCqKcO0xrCjMF8REiPlR3HRFKw%3A1676591329209&ei=4cDuY6WuDIuYptQPq5WFiA0&ved=0ahUKEwjlovG0nZv9AhULjIkEHatKAdEQ4dUDCBA&uact=5&oq=python+image+similarity+pil&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIJCAAQFhAeEPEEMgUIABCGAzIFCAAQhgMyBQgAEIYDMgUIABCGAzoKCAAQRxDWBBCwAzoECAAQQzoFCAAQgAQ6BggAEBYQHkoECEEYAFDaA1jOCWDFDmgBcAF4AIABlQGIAfMDkgEDMS4zmAEAoAEByAEIwAEB&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+image+similarity+pil&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzUfhCqKcO0xrCjMF8REiPlR3HRFKw%3A1676591329209&ei=4cDuY6WuDIuYptQPq5WFiA0&ved=0ahUKEwjlovG0nZv9AhULjIkEHatKAdEQ4dUDCBA&uact=5&oq=python+image+similarity+pil&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIJCAAQFhAeEPEEMgUIABCGAzIFCAAQhgMyBQgAEIYDMgUIABCGAzoKCAAQRxDWBBCwAzoECAAQQzoFCAAQgAQ6BggAEBYQHkoECEEYAFDaA1jOCWDFDmgBcAF4AIABlQGIAfMDkgEDMS4zmAEAoAEByAEIwAEB&sclient=gws-wiz-serp")'>python image similarity pil</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot99.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/52736154/how-to-check-similarity-of-two-images-that-have-different-pixelization' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/52736154/how-to-check-similarity-of-two-images-that-have-different-pixelization")'>python - How to check similarity of two images that have different pixelization - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+jpg+similarity&rlz=1C5CHFA_enUS863US865&oq=python+jpg+similarity&aqs=chrome..69i57j33i160l2.3440j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+jpg+similarity&rlz=1C5CHFA_enUS863US865&oq=python+jpg+similarity&aqs=chrome..69i57j33i160l2.3440j0j7&sourceid=chrome&ie=UTF-8")'>python jpg similarity</a></span></div><hr>
<div class='webImageLongRow'>
</div>
</div>

<button type='button' class='collapsible'>search: numpy initialize array of strings;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=pil+image+to+numpy+array&rlz=1C5CHFA_enUS863US865&oq=pil+image+to+&aqs=chrome.1.69i57j0i512l4j69i60l3.5271j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=pil+image+to+numpy+array&rlz=1C5CHFA_enUS863US865&oq=pil+image+to+&aqs=chrome.1.69i57j0i512l4j69i60l3.5271j0j4&sourceid=chrome&ie=UTF-8")'>pil image to numpy array</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot100.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/384759/how-do-i-convert-a-pil-image-into-a-numpy-array' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/384759/how-do-i-convert-a-pil-image-into-a-numpy-array")'>python - How do I convert a PIL Image into a NumPy array? - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+mean+square+error&rlz=1C5CHFA_enUS863US865&oq=numpy+mean+square+erro&aqs=chrome.0.0i512j69i57j0i22i30i625j0i22i30l6j0i390.3449j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=numpy+mean+square+error&rlz=1C5CHFA_enUS863US865&oq=numpy+mean+square+erro&aqs=chrome.0.0i512j69i57j0i22i30i625j0i22i30l6j0i390.3449j0j7&sourceid=chrome&ie=UTF-8")'>numpy mean square error</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot103.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy")'>python - Mean Squared Error in Numpy? - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot102.png' width='180' height='112'> </td></tr><tr><td><a href='https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.hist.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.hist.html")'>matplotlib.pyplot.hist  Matplotlib 3.7.0 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot103.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy")'>python - Mean Squared Error in Numpy? - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+array+of+strings&rlz=1C5CHFA_enUS863US865&oq=numpy+array+of+strings&aqs=chrome..69i57j0i512l3j0i22i30i625j0i22i30l2j0i22i30i625j0i22i30l2.4567j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=numpy+array+of+strings&rlz=1C5CHFA_enUS863US865&oq=numpy+array+of+strings&aqs=chrome..69i57j0i512l3j0i22i30i625j0i22i30l2j0i22i30i625j0i22i30l2.4567j0j7&sourceid=chrome&ie=UTF-8")'>numpy array of strings</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot104.png' width='180' height='112'> </td></tr><tr><td><a href='https://numpy.org/doc/stable/reference/generated/numpy.chararray.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://numpy.org/doc/stable/reference/generated/numpy.chararray.html")'>numpy.chararray  NumPy v1.24 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot117.png' width='180' height='112'> </td></tr><tr><td><a href='https://numpy.org/doc/stable/reference/generated/numpy.matrix.T.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://numpy.org/doc/stable/reference/generated/numpy.matrix.T.html")'>numpy.matrix.T  NumPy v1.24 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot106.png' width='180' height='112'> </td></tr><tr><td><a href='https://numpy.org/doc/stable/reference/generated/numpy.matrix.H.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://numpy.org/doc/stable/reference/generated/numpy.matrix.H.html")'>numpy.matrix.H  NumPy v1.24 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot107.png' width='180' height='112'> </td></tr><tr><td><a href='https://numpy.org/doc/stable/reference/generated/numpy.record.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://numpy.org/doc/stable/reference/generated/numpy.record.html")'>numpy.record  NumPy v1.24 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot108.png' width='180' height='112'> </td></tr><tr><td><a href='https://numpy.org/doc/stable/reference/arrays.classes.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://numpy.org/doc/stable/reference/arrays.classes.html")'>Standard array subclasses  NumPy v1.24 Manual</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+initialize+array+of+strings&rlz=1C5CHFA_enUS863US865&oq=numpy+initialize+array+of+strings&aqs=chrome..69i57j0i22i30i625j0i22i30.5081j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=numpy+initialize+array+of+strings&rlz=1C5CHFA_enUS863US865&oq=numpy+initialize+array+of+strings&aqs=chrome..69i57j0i22i30i625j0i22i30.5081j0j4&sourceid=chrome&ie=UTF-8")'>numpy initialize array of strings</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot109.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/14639496/how-to-create-a-numpy-array-of-arbitrary-length-strings' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/14639496/how-to-create-a-numpy-array-of-arbitrary-length-strings")'>python - How to create a numpy array of arbitrary length strings? - Stack Overflow</a></td></tr></tbody></table></div>
</div>
</div>

<button type='button' class='collapsible'>main.py: Calculate Mean Squared Error (MSE) between images to measure similarity</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


img = Image.open("target_angie.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)
print(arr.shape)

img2 = Image.open("target_photo.jpg")
img2.draft("RGB",(50,50))
image_matrix2 = img2.load()


#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("angie_bed2.jpg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region15')">def compare_image_distance(img1, img2):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region38')">    img = Image.open(angie_bed1.jpg)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region39')">    img2 = Image.open(angie_bed2.jpg)</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Check if MSE is under a threshold to detect near-identical photos, print out histogram of all MSEs</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("angie_bed2.jpg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)
MSES = []
import matplotlib.pyplot as plt
for file in file_image_map.keys():
    img2 = file_image_map[file].resize((50,50), Image.ANTIALIAS)
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 90:
        print(file, mse)
    MSES.append(mse)
plt.hist(MSES)
plt.show()




#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region39')">    img2 = Image.open(angie_bed2.jpg)</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Load in test photo to see how well it works</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


img = Image.open("Photos/PXL_20210215_194754789.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)
file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    print(file)
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 90:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)
file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 90:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
</ul>
</div></div><div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal72">
		<legend>Sub-goal</legend>
		<div>Make sure that duplicate or similar-looking photos aren't adjacent in mosaic</div>
	</fieldset>
<button type='button' class='collapsible'>main.py: Record which files have been added to mosaic in a matrix</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img#.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



make_mosaic_avg(target_photo, photos_dir)
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = np.array([["" for i in range(height)] for j in range(width)]) #parallel matrix to what we"re building

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img#.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[x,y] = closest_file
            print(filename_matrix[x,y], closest_file)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region40')">img = make_mosaic_avg(target_photo, photos_dir, basewidth=basewidth, pixelWidth=pixelWidth)</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Before adding an image to the mosaic, looping through nearby appended files to check if they are too similar</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = np.array([["" for i in range(height)] for j in range(width)]) #parallel matrix to what we"re building

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img#.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[x,y] = closest_file
            print(filename_matrix[x,y], closest_file)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 2
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2

    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = unique_photos_necessary_in_window)[1]
            for pixel_index in nearest_neighbors_indexes:
                #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                neighbor_pixel = all_avg_pixels[pixel_index]
                neighbor_file = pixel_files_map[neighbor_pixel][0]
                neighbor_image = file_image_map[neighbor_file]

                window_x_min = max(0, x-min_array_distance_between_similar_photos)
                window_y_min = max(0, y-min_array_distance_between_similar_photos)
                for window_y in range(window_y_min, y):
                    for window_x in range(window_x_min, x):
                        if not (window_y == y and window_x == x):
                            window_file = filename_matrix[window_y][window_x]
                closest_img = neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(neighbor_file)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region30')">            #add new image object running row image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region31')">def make_mosaic_avg(target_photo, photos_dir=Photos/, basewidth=50, pixelWidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region32')">    for y in range(height):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region33')">                    window_x_min = max(0, x-min_array_distance_between_similar_photos)</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Reworking this logic to stop looping through the closest file candidates once a valid image has been found</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 2
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2

    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = unique_photos_necessary_in_window)[1]
            for pixel_index in nearest_neighbors_indexes:
                #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                neighbor_pixel = all_avg_pixels[pixel_index]
                neighbor_file = pixel_files_map[neighbor_pixel][0]
                neighbor_image = file_image_map[neighbor_file]

                window_x_min = max(0, x-min_array_distance_between_similar_photos)
                window_y_min = max(0, y-min_array_distance_between_similar_photos)
                for window_y in range(window_y_min, y):
                    for window_x in range(window_x_min, x):
                        if not (window_y == y and window_x == x):
                            window_file = filename_matrix[window_y][window_x]
                closest_img = neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(neighbor_file)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 2
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2

    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = unique_photos_necessary_in_window)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                    else: 
                        for window_y in range(window_y_min, y):
                            for window_x in range(window_x_min, x):
                                if not (window_y == y and window_x == x):
                                    window_file = filename_matrix[window_y][window_x]
                                    window_img = file_image_map[window_file]
                                    image_distance = compare_image_distance(neighbor_image, window_img)
                                    if image_distance > 85:
                                        valid_image_found = True
                                        image_toAdd = neighbor_image

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(neighbor_file)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region32')">    for y in range(height):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region33')">                    window_x_min = max(0, x-min_array_distance_between_similar_photos)</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Add function for compare_image_distance()</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 2
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2

    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = unique_photos_necessary_in_window)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                    else: 
                        for window_y in range(window_y_min, y):
                            for window_x in range(window_x_min, x):
                                if not (window_y == y and window_x == x):
                                    window_file = filename_matrix[window_y][window_x]
                                    window_img = file_image_map[window_file]
                                    image_distance = compare_image_distance(neighbor_image, window_img)
                                    if image_distance > 85:
                                        valid_image_found = True
                                        image_toAdd = neighbor_image

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(neighbor_file)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 3
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2

    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = unique_photos_necessary_in_window)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd =4
                        isValid = True #starts true, then gets disqualified potentially
                        print("NEXT")
                        for window_y in range(window_y_min, y):
                            if not valid_image_found:
                                for window_x in range(window_x_min, x):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x == x):
                                            window_file = filename_matrix[window_y][window_x]
                                            #print("\t", "y",window_y, "x", window_x, window_file)
                                            window_img = file_image_map[window_file]
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        if isValid:
                            print("valid image found!")
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()

img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region15')">def compare_image_distance(img1, img2):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region31')">def make_mosaic_avg(target_photo, photos_dir=Photos/, basewidth=50, pixelWidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region33')">                    window_x_min = max(0, x-min_array_distance_between_similar_photos)</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Test sliding window sizes, and how for larger sliding window sizes, we need to bring in more candidate images</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 3
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = unique_photos_necessary_in_window)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd =4
                        isValid = True #starts true, then gets disqualified potentially
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, x+1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x == x):
                                            window_file = filename_matrix[window_y][window_x]
                                            #print("\t", "y",window_y, "x", window_x, window_file)
                                            window_img = file_image_map[window_file]
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()

img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=80)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 7
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            #print("\t", "y",window_y, "x", window_x, window_file)
                                            window_img = file_image_map[window_file]
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()

img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region31')">def make_mosaic_avg(target_photo, photos_dir=Photos/, basewidth=50, pixelWidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region32')">    for y in range(height):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region33')">                    window_x_min = max(0, x-min_array_distance_between_similar_photos)</li>
</ul>
</div></div><div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal79">
		<legend>Sub-goal</legend>
		<div>Runtime improvements</div>
	</fieldset>
<button type='button' class='collapsible'>main.py: Vectorize: one images to many images similarity comparison</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=80)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 7
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            #print("\t", "y",window_y, "x", window_x, window_file)
                                            window_img = file_image_map[window_file]
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()

img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    arr_images = np.array([np.array(x) for x in window_imgs])
    MSEs = ((arr_img-arr_img)**2)
    print(MSEs)
    #MSEs.mean().mean()

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=80)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 7
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            # image_distance = compare_image_distance(neighbor_image, window_img)
                                            # if image_distance < 85:
                                            #     isValid = False
                        image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        print(image_distances)
                        exit()
                        if image_distances.max() < 85:
                            isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()

img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region16')">def compare_image_to_images_distances(neighbor_image, window_imgs):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region17')">        neighbor_image: PIL Image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region33')">                    window_x_min = max(0, x-min_array_distance_between_similar_photos)</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Debugging vectorization syntax in numpy</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    arr_images = np.array([np.array(x) for x in window_imgs])
    MSEs = ((arr_img-arr_img)**2)
    print(MSEs)
    #MSEs.mean().mean()

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=80)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 7
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            # image_distance = compare_image_distance(neighbor_image, window_img)
                                            # if image_distance < 85:
                                            #     isValid = False
                        image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        print(image_distances)
                        exit()
                        if image_distances.max() < 85:
                            isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()

img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    arr_images = np.array([np.array(x) for x in window_imgs])
    MSEs = ((arr_img-arr_img)**2)
    print(MSEs.shape)
    print(MSEs.mean().shape)
    print(MSEs.mean())
    #MSEs.mean().mean()

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=80)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 7
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            # image_distance = compare_image_distance(neighbor_image, window_img)
                                            # if image_distance < 85:
                                            #     isValid = False
                        image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        print(image_distances)
                        exit()
                        if image_distances.max() < 85:
                            isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir)
# img.save("mosaic.jpg")
# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

vector_arr = np.array([arr2 for i in range(10)])
print(vector_arr.shape, arr.shape)
print((vector_arr - arr).mean(axis=1).mean(axis=1).shape)


exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region40')">img = make_mosaic_avg(target_photo, photos_dir, basewidth=basewidth, pixelWidth=pixelWidth)</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Rework debugging steps into function</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    arr_images = np.array([np.array(x) for x in window_imgs])
    MSEs = ((arr_img-arr_img)**2)
    print(MSEs.shape)
    print(MSEs.mean().shape)
    print(MSEs.mean())
    #MSEs.mean().mean()

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=80)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 7
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            # image_distance = compare_image_distance(neighbor_image, window_img)
                                            # if image_distance < 85:
                                            #     isValid = False
                        image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        print(image_distances)
                        exit()
                        if image_distances.max() < 85:
                            isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir)
# img.save("mosaic.jpg")
# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

vector_arr = np.array([arr2 for i in range(10)])
print(vector_arr.shape, arr.shape)
print((vector_arr - arr).mean(axis=1).mean(axis=1).shape)


exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])

#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

randarr =  np.random.rand(3,3,4)
print(randarr, randarr.shape)

vector_arr = np.array([np.ones((3, 3, 4)), np.zeros((3, 3, 4)), randarr])
vector_arr2 = vector_arr.transpose()#np.array([randarr, np.zeros((3, 3, 4)), np.ones((3, 3, 4))])

print(vector_arr.shape)
print(vector_arr2.shape)
Es = (vector_arr - vector_arr2)
print(Es)
print(Es.shape)
print(Es.mean(axis=2).shape)


exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region17')">        neighbor_image: PIL Image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region31')">def make_mosaic_avg(target_photo, photos_dir=Photos/, basewidth=50, pixelWidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region33')">                    window_x_min = max(0, x-min_array_distance_between_similar_photos)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region39')">    img2 = Image.open(angie_bed2.jpg)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region40')">img = make_mosaic_avg(target_photo, photos_dir, basewidth=basewidth, pixelWidth=pixelWidth)</li>
</ul>
</div><button type='button' class='collapsible'>search: numpy matrix operations;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=python+subtract+arrays+of+vectors&rlz=1C5CHFA_enUS863US865&oq=python+subtract+arrays+of+vectors&aqs=chrome..69i57j33i160j33i299j33i22i29i30l3.21615j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=python+subtract+arrays+of+vectors&rlz=1C5CHFA_enUS863US865&oq=python+subtract+arrays+of+vectors&aqs=chrome..69i57j33i160j33i299j33i22i29i30l3.21615j0j7&sourceid=chrome&ie=UTF-8")'>python subtract arrays of vectors</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+random+array+of+shape&rlz=1C5CHFA_enUS863US865&oq=numpy+random+array+of+shape&aqs=chrome..69i57j0i512j0i22i30i625l4j0i22i30l2j0i22i30i625.2744j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=numpy+random+array+of+shape&rlz=1C5CHFA_enUS863US865&oq=numpy+random+array+of+shape&aqs=chrome..69i57j0i512j0i22i30i625l4j0i22i30l2j0i22i30i625.2744j0j7&sourceid=chrome&ie=UTF-8")'>numpy random array of shape</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+MSE+of+multiple+parallel+arrays&rlz=1C5CHFA_enUS863US865&oq=numpy+MSE+of+multiple+parallel+arrays&aqs=chrome..69i57j33i160.6473j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=numpy+MSE+of+multiple+parallel+arrays&rlz=1C5CHFA_enUS863US865&oq=numpy+MSE+of+multiple+parallel+arrays&aqs=chrome..69i57j33i160.6473j0j7&sourceid=chrome&ie=UTF-8")'>numpy MSE of multiple parallel arrays</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot113.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/51435992/python-fast-mean-squared-error-between-two-large-2d-lists' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/51435992/python-fast-mean-squared-error-between-two-large-2d-lists")'>performance - python fast mean squared error between two large 2d lists - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+MSE+of+multiple+parallel+3d+arrays&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzXV4s7_-3Q7LjZUBLEbS-nTY0N6-g%3A1676656007893&ei=h73vY6WENqugptQPyrikqAk&ved=0ahUKEwjl44qujp39AhUrkIkEHUocCZUQ4dUDCBA&uact=5&oq=numpy+MSE+of+multiple+parallel+3d+arrays&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCAAQogQyBQgAEKIEMgUIABCiBDIFCAAQogQyCggAEPEEEB4QogQ6CggAEEcQ1gQQsAM6BAgjECdKBAhBGABQzghYswxg_RFoAXAAeACAAYABiAGlApIBAzIuMZgBAKABAcgBCMABAQ&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=numpy+MSE+of+multiple+parallel+3d+arrays&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzXV4s7_-3Q7LjZUBLEbS-nTY0N6-g%3A1676656007893&ei=h73vY6WENqugptQPyrikqAk&ved=0ahUKEwjl44qujp39AhUrkIkEHUocCZUQ4dUDCBA&uact=5&oq=numpy+MSE+of+multiple+parallel+3d+arrays&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCAAQogQyBQgAEKIEMgUIABCiBDIFCAAQogQyCggAEPEEEB4QogQ6CggAEEcQ1gQQsAM6BAgjECdKBAhBGABQzghYswxg_RFoAXAAeACAAYABiAGlApIBAzIuMZgBAKABAcgBCMABAQ&sclient=gws-wiz-serp")'>numpy MSE of multiple parallel 3d arrays</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot118.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/66236344/compute-root-mean-squared-error-and-obtain-a-3d-array-in-python' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://stackoverflow.com/questions/66236344/compute-root-mean-squared-error-and-obtain-a-3d-array-in-python")'>numpy - Compute Root Mean Squared Error and obtain a 3D array in Python - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+matrix+operations&rlz=1C5CHFA_enUS863US865&oq=numpy+matrix+operations&aqs=chrome.0.0i512l2j0i22i30l3j0i22i30i625j0i22i30j0i22i30i625j0i22i30l2.6033j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=numpy+matrix+operations&rlz=1C5CHFA_enUS863US865&oq=numpy+matrix+operations&aqs=chrome.0.0i512l2j0i22i30l3j0i22i30i625j0i22i30j0i22i30i625j0i22i30l2.6033j0j7&sourceid=chrome&ie=UTF-8")'>numpy matrix operations</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot115.png' width='180' height='112'> </td></tr><tr><td><a href='https://towardsdatascience.com/top-10-matrix-operations-in-numpy-with-examples-d761448cb7a8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://towardsdatascience.com/top-10-matrix-operations-in-numpy-with-examples-d761448cb7a8")'>Top 10 Matrix Operations in Numpy with Examples | by Rukshan Pramoditha | Towards Data Science</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot116.png' width='180' height='112'> </td></tr><tr><td><a href='https://numpy.org/doc/stable/reference/generated/numpy.matrix.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://numpy.org/doc/stable/reference/generated/numpy.matrix.html")'>numpy.matrix  NumPy v1.24 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot117.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://numpy.org/doc/stable/reference/generated/numpy.matrix.T.html' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://numpy.org/doc/stable/reference/generated/numpy.matrix.T.html")'>numpy.matrix.T  NumPy v1.24 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot118.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://stackoverflow.com/questions/66236344/compute-root-mean-squared-error-and-obtain-a-3d-array-in-python' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open revisit: https://stackoverflow.com/questions/66236344/compute-root-mean-squared-error-and-obtain-a-3d-array-in-python")'>numpy - Compute Root Mean Squared Error and obtain a 3D array in Python - Stack Overflow</a></td></tr></tbody></table></div>
</div>
</div>

</div><div style="margin-top: 15px; border-top: 1px;" ></div>
	<fieldset class="goal" style="width: 100%;" id="subgoal85">
		<legend>Sub-goal</legend>
		<div>Testing and Cleaning Code -- final touches</div>
	</fieldset>
<button type='button' class='collapsible'>main.py: Testing running code with different parameters for image similarity threshold and number of neighbors retreived</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def get_all_image_comparisons_matrix(file_image_map):
    file_index_map = {}
    index = 0
    all_distances = []
    for file in file_image_map.keys():
        file_distances = []
        img = file_image_map[file]
        file_index_map[file] = index
        index += 1
        for compare_file in file_image_map.keys():
            compare_image = file_image_map[compare_file]
            distance = compare_image_distance(img, compare_image)
            file_distances.append(distance)
    return file_index_map, all_distances

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    file_index_map, all_distances_matrix = get_all_image_comparisons_matrix(file_image_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]
                    neighbor_distance_index = file_index_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_file_index = file_index_map[window_file]
                                            image_distance = all_distances_matrix[neighbor_distance_index][window_file_index]
                                            # window_img = file_image_map[window_file]
                                            # window_imgs.append(window_img)
                                            # image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
img.save("mosaic.jpg")

exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_me.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def get_all_image_comparisons_matrix(file_image_map):
    file_index_map = {}
    index = 0
    all_distances = []
    for file in file_image_map.keys():
        file_distances = []
        img = file_image_map[file]
        file_index_map[file] = index
        index += 1
        for compare_file in file_image_map.keys():
            compare_image = file_image_map[compare_file]
            distance = compare_image_distance(img, compare_image)
            file_distances.append(distance)
        all_distances.append(file_distances)
    print(np.array(all_distances).shape)
    return file_index_map, all_distances

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    file_index_map, all_distances_matrix = get_all_image_comparisons_matrix(file_image_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 200)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]
                    neighbor_distance_index = file_index_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4 #this is for debugging to ensure we don"t accidentally recycle this variable in the loop
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_file_index = file_index_map[window_file]
                                            image_distance = all_distances_matrix[neighbor_distance_index][window_file_index]
                                            # window_img = file_image_map[window_file]
                                            # window_imgs.append(window_img)
                                            # image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir, basewidth=60)
img.save("mosaic_meAngie.jpg")

exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region18')">def get_all_image_comparisons_matrix(file_image_map):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region20')">    file_index_map = {}</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region31')">def make_mosaic_avg(target_photo, photos_dir=Photos/, basewidth=50, pixelWidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region32')">    for y in range(height):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region33')">                    window_x_min = max(0, x-min_array_distance_between_similar_photos)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region36')">target_photo = angie_flower.jpeg</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region40')">img = make_mosaic_avg(target_photo, photos_dir, basewidth=basewidth, pixelWidth=pixelWidth)</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Add comments to functions</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir, width=50):
    height = width #square image
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(width,height))
            img = img.resize((width, height), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def get_all_image_comparisons_matrix(file_image_map):
    file_index_map = {}
    index = 0
    all_distances = []
    for file in file_image_map.keys():
        file_distances = []
        img = file_image_map[file]
        file_index_map[file] = index
        index += 1
        for compare_file in file_image_map.keys():
            compare_image = file_image_map[compare_file]
            distance = compare_image_distance(img, compare_image)
            file_distances.append(distance)
        all_distances.append(file_distances)
    print(np.array(all_distances).shape)
    return file_index_map, all_distances

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50, pixelWidth=50):
    """
    This function takes in a target_photo filename, a photos_dir directory name, the basewidth of pixels for the target image to be reshaped to,
    and the pixelWidth, which is the width of each image replacing each pixel in the resized target image
    """
    #maps filenames to PIL image objects
    file_image_map = get_file_image_map(photos_dir, width = pixelWidth)

    #maps filenames to the file"s average pixel value
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)

    #maps avg pixel values back to filenames
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)

    #array of all average pixels. There should be one element per file.
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    #gets a matrix of all image similarity comparisons, as well as a mapping from filename to index in the matrix. 
    file_index_map, all_distances_matrix = get_all_image_comparisons_matrix(file_image_map)

    #initialize datatype for quick lookup of similar pixels
    nearest_neighbors_tree = KDTree(all_avg_pixels)

    #load and prep image
    img = Image.open(target_photo)
    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    #initialize matrix to be used to check nearby appended images so as to not add a duplicate
    filename_matrix = []

    #basically window size in sliding window algorithm
    min_array_distance_between_similar_photos = 5

    #loop through each pixel of the target image
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            #select 200 nearest neighbors
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 200)[1]
            #loop through sliding window of filenames appended nearby to ensure no similar images are near
            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]
                    neighbor_distance_index = file_index_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4 #this is for debugging to ensure we don"t accidentally recycle this variable in the loop
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_file_index = file_index_map[window_file]
                                            image_distance = all_distances_matrix[neighbor_distance_index][window_file_index]
                                            if image_distance < 85:
                                                isValid = False
                        #if isValid is still true, then set flags to continue out of these loops
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file
            #add image_toAdd to row
            if x == 0:
                row_image = image_toAdd
            else:
                row_image = get_concat_h(row_image, image_toAdd)
            
            #add filename of appended image to filename_matrix
            filename_matrix[y].append(filename_toAdd)
        
        #append row of images to an image of all previous columns
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    #return all columns of images of rows of images appended together
    return column_image


img = make_mosaic_avg(target_photo, photos_dir, basewidth=60, pixelWidth=200)
img.save("mosaic.jpg")
' --end-code='from PIL import Image
import numpy as np
import os
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans
import pandas as pd

def get_avg_pixel(img):
     """
     Parameters: img (PIL Image object)
     returns: average pixel (RGB tuple)
     """
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    """
     Parameters:
        file_image_map : (dictionary mapping filenames to their respective PIL Image objects)
     Returns: 
        dictionary mapping filenames to their average calculated pixel value (RGB tuple)
     """
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        

def get_file_image_map(photos_dir, width=50):
    """
    Parameters:
        photos_dir : name of directory with photos to make mosaic in it (string)
        width: width in pixels to downscale images to for faster processing and uniform shape (int)
    Returns:
        dictionary mapping filenames to their respective PIL images
    """
    height = width #square image
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(width,height))
            img = img.resize((width, height), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    """
    Parameters: 
        im1: PIL image
        im2: PIL image
    Returns:
        PIL image of im1 and im2 being concatenated together horizontally, im1 on left side of im2
    """
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    """
    Parameters: 
        im1: PIL image
        im2: PIL image
    Returns:
        PIL image of im1 and im2 being concatenated together vertically, im1 above im2
    """
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    """
    Parameters:
        pixel_map : dictionary mapping filename to average pixel
    Returns:
        dictionary mapping average pixel to a list of filenames with that pixel average
    """
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    """
    Parameters:
        file_image_map: dictionary mapping filenames to PIL images
    Returns:
        array of all pixel values
    """
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    """
    Parameters:
        img: PIL Image
        basewidth: int
    Returns:
        PIL Image rescaled proportionally such that its new base = basewidth
    """
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    """
    This function performs a kmeans cluster on each image, clustering the array of pixels to identify dominant colors.

    Parameters:
        file_image_map: dictionary mapping filename to respective PIL Image
    Returns:
        Pandas Dataframe linking together:
            filename (string)
            each color cluster centroid (RGB tuple)
            estimated percent of the image falls into that color cluster (float)
    """

    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    """
    Parameters: 
        s : string in format "(a, b, c)" where a, b, and c are RGB values
    Returns:
        RGB tuple in format (R, G, B)
    """
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    """
    Parameters: 
        img1: PIL Image
        img2: PIL Image
    Returns:
        Mean Squared Error between the pixel values of the two images
    """
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    """
    Vectorized comparison of an image to an array of images

    Parameters:
        neighbor_image: PIL Image
        window_imgs: array of PIL Images
    Returns:
        array of MSE distances between neighbor_image and each image of window_imgs
    """
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def get_all_image_comparisons_matrix(file_image_map):
    """
    Generates a matrix of all Mean Squared Errors between every combination of PIL Images.

    Parameters:
        file_image_map : dictionary mapping filename to its respective PIL Image object
    Returns:
        file_index_map : dictionary mapping filename to its index location in the matrix (for quick lookups)
        all_distances : matrix of dimension (num_images X num_images) of all Mean Squared Errors

    """
    file_index_map = {}
    index = 0
    all_distances = []
    for file in file_image_map.keys():
        file_distances = []
        img = file_image_map[file]
        file_index_map[file] = index
        index += 1
        for compare_file in file_image_map.keys():
            compare_image = file_image_map[compare_file]
            distance = compare_image_distance(img, compare_image)
            file_distances.append(distance)
        all_distances.append(file_distances)
    print(np.array(all_distances).shape)
    return file_index_map, all_distances

def make_mosaic_kmeans(target_photo, photos_dir="Photos/", first_run = False):
    """
    Generates a photo mosaic image of a target photo given a folder of images.
    This method uses kmeans clustering to extract the top 4 dominant colors of an image, and then
    map each pixel of the target image to an image in photos_dir that includes a high yield of a
    dominant color that is similar to that given pixel.

    This approach was experimentally less succesful than the average pixel mapping algorithm, "make_mosaic_avg"

    Parameters:
        target_photo : filename of target photo (string)
        photos_dir : name of folder of images (string)
        first_run : Boolean if this is the first time this method is being run
            This method includes a time-extensive method which should only be run once per photo_dir
    Returns:
        PIL Image of generated photo mosaic
    """

    #get dictionary mapping each filename to its respective image
    file_image_map = get_file_image_map(photos_dir)
    
    #only run kmeans clustering the first time you do this, so you can use the same set of photos for multiple target images without running this often
    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    #get list of all centroids
    all_centroids = kmeans_dataframe["centroid"].tolist()

    #initialize KD Tree
    nearest_neighbors_tree = KDTree(all_centroids)

    #prep image
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    #loop through each pixel of the target image
    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            #find the 10 photos that have a dominant centroid most near the current pixel
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            
            #generate subset of kmeans_dataframe that includes only the top-10 nearest neighbors
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)

            # pick a random image of the top 10 centroid matches
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            
            #gets the image given the filename
            closest_img = file_image_map[closest_file]

            #add new image object running row image
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
        #add row image object to running column image
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    #return stack of images as one
    return column_image

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50, pixelWidth=50):
    """
    This function takes in a target_photo filename, a photos_dir directory name, the basewidth of pixels for the target image to be reshaped to,
    and the pixelWidth, which is the width of each image replacing each pixel in the resized target image
    """
    #maps filenames to PIL image objects
    file_image_map = get_file_image_map(photos_dir, width = pixelWidth)

    #maps filenames to the file"s average pixel value
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)

    #maps avg pixel values back to filenames
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)

    #array of all average pixels. There should be one element per file.
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    #gets a matrix of all image similarity comparisons, as well as a mapping from filename to index in the matrix. 
    file_index_map, all_distances_matrix = get_all_image_comparisons_matrix(file_image_map)

    #initialize datatype for quick lookup of similar pixels
    nearest_neighbors_tree = KDTree(all_avg_pixels)

    #load and prep image
    img = Image.open(target_photo)
    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    #initialize matrix to be used to check nearby appended images so as to not add a duplicate
    filename_matrix = []

    #basically window size in sliding window algorithm
    min_array_distance_between_similar_photos = 5

    #loop through each pixel of the target image
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            #select 200 nearest neighbors
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 200)[1]
            #loop through sliding window of filenames appended nearby to ensure no similar images are near
            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]
                    neighbor_distance_index = file_index_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4 #this is for debugging to ensure we don"t accidentally recycle this variable in the loop
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_file_index = file_index_map[window_file]
                                            image_distance = all_distances_matrix[neighbor_distance_index][window_file_index]
                                            if image_distance < 85:
                                                isValid = False
                        #if isValid is still true, then set flags to continue out of these loops
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file
            #add image_toAdd to row
            if x == 0:
                row_image = image_toAdd
            else:
                row_image = get_concat_h(row_image, image_toAdd)
            
            #add filename of appended image to filename_matrix
            filename_matrix[y].append(filename_toAdd)
        
        #append row of images to an image of all previous columns
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    #return all columns of images of rows of images appended together
    return column_image


target_photo = "angie_flower.jpeg"
photos_dir = "Photos/"
img = make_mosaic_avg(target_photo, photos_dir, basewidth=60, pixelWidth=200)
img.save("mosaic.jpg")
' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region0')">from PIL import Image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region1')">def get_avg_pixel(img):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region2')">def get_file_avgPixelMap(file_image_map):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region3')">def get_file_image_map(photos_dir, width=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region5')">def get_concat_h(im1, im2):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region6')">def get_concat_v(im1, im2):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region7')">def get_pixel_files_map(pixel_map):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region8')">def get_all_avg_pixels_array(file_image_map):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region9')">def scale_image_to_basewidth(img, basewidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region10')">def get_kmeans_dataframe_all_photos(file_image_map):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region11')">    Parameters:</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region14')">def string_to_tuple(s):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region15')">def compare_image_distance(img1, img2):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region16')">def compare_image_to_images_distances(neighbor_image, window_imgs):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region17')">        neighbor_image: PIL Image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region18')">def get_all_image_comparisons_matrix(file_image_map):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region19')">        file_image_map : dictionary mapping filename to its respective PIL Image object</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region21')">def make_mosaic_kmeans(target_photo, photos_dir=Photos/, first_run = False):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region22')">    This approach was experimentally less succesful than the average pixel mapping algorithm, make_mosaic_avg</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region23')">        target_photo : filename of target photo (string)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region24')">    #get dictionary mapping each filename to its respective image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region25')">    #get list of all centroids</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region27')">    #loop through each pixel of the target image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region28')">            #generate subset of kmeans_dataframe that includes only the top-10 nearest neighbors</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region29')">            # pick a random image of the top 10 centroid matches</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region30')">            #add new image object running row image</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region31')">def make_mosaic_avg(target_photo, photos_dir=Photos/, basewidth=50, pixelWidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region32')">    for y in range(height):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region33')">                    window_x_min = max(0, x-min_array_distance_between_similar_photos)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region36')">target_photo = angie_flower.jpeg</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region38')">    img = Image.open(angie_bed1.jpg)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region39')">    img2 = Image.open(angie_bed2.jpg)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region40')">img = make_mosaic_avg(target_photo, photos_dir, basewidth=basewidth, pixelWidth=pixelWidth)</li>
</ul>
</div><button type='button' class='collapsible'>main.py: Test how resizing photos impacts calculated MSE averages</button>
<div class='content' --start-code='from PIL import Image
import numpy as np
import os
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans
import pandas as pd

def get_avg_pixel(img):
     """
     Parameters: img (PIL Image object)
     returns: average pixel (RGB tuple)
     """
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    """
     Parameters:
        file_image_map : (dictionary mapping filenames to their respective PIL Image objects)
     Returns: 
        dictionary mapping filenames to their average calculated pixel value (RGB tuple)
     """
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        

def get_file_image_map(photos_dir, width=50):
    """
    Parameters:
        photos_dir : name of directory with photos to make mosaic in it (string)
        width: width in pixels to downscale images to for faster processing and uniform shape (int)
    Returns:
        dictionary mapping filenames to their respective PIL images
    """
    height = width #square image
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(width,height))
            img = img.resize((width, height), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    """
    Parameters: 
        im1: PIL image
        im2: PIL image
    Returns:
        PIL image of im1 and im2 being concatenated together horizontally, im1 on left side of im2
    """
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    """
    Parameters: 
        im1: PIL image
        im2: PIL image
    Returns:
        PIL image of im1 and im2 being concatenated together vertically, im1 above im2
    """
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    """
    Parameters:
        pixel_map : dictionary mapping filename to average pixel
    Returns:
        dictionary mapping average pixel to a list of filenames with that pixel average
    """
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    """
    Parameters:
        file_image_map: dictionary mapping filenames to PIL images
    Returns:
        array of all pixel values
    """
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    """
    Parameters:
        img: PIL Image
        basewidth: int
    Returns:
        PIL Image rescaled proportionally such that its new base = basewidth
    """
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    """
    This function performs a kmeans cluster on each image, clustering the array of pixels to identify dominant colors.

    Parameters:
        file_image_map: dictionary mapping filename to respective PIL Image
    Returns:
        Pandas Dataframe linking together:
            filename (string)
            each color cluster centroid (RGB tuple)
            estimated percent of the image falls into that color cluster (float)
    """

    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    """
    Parameters: 
        s : string in format "(a, b, c)" where a, b, and c are RGB values
    Returns:
        RGB tuple in format (R, G, B)
    """
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    """
    Parameters: 
        img1: PIL Image
        img2: PIL Image
    Returns:
        Mean Squared Error between the pixel values of the two images
    """
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    """
    Vectorized comparison of an image to an array of images

    Parameters:
        neighbor_image: PIL Image
        window_imgs: array of PIL Images
    Returns:
        array of MSE distances between neighbor_image and each image of window_imgs
    """
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def get_all_image_comparisons_matrix(file_image_map):
    """
    Generates a matrix of all Mean Squared Errors between every combination of PIL Images.

    Parameters:
        file_image_map : dictionary mapping filename to its respective PIL Image object
    Returns:
        file_index_map : dictionary mapping filename to its index location in the matrix (for quick lookups)
        all_distances : matrix of dimension (num_images X num_images) of all Mean Squared Errors

    """
    file_index_map = {}
    index = 0
    all_distances = []
    for file in file_image_map.keys():
        file_distances = []
        img = file_image_map[file]
        file_index_map[file] = index
        index += 1
        for compare_file in file_image_map.keys():
            compare_image = file_image_map[compare_file]
            distance = compare_image_distance(img, compare_image)
            file_distances.append(distance)
        all_distances.append(file_distances)
    print(np.array(all_distances).shape)
    return file_index_map, all_distances

def make_mosaic_kmeans(target_photo, photos_dir="Photos/", first_run = False):
    """
    Generates a photo mosaic image of a target photo given a folder of images.
    This method uses kmeans clustering to extract the top 4 dominant colors of an image, and then
    map each pixel of the target image to an image in photos_dir that includes a high yield of a
    dominant color that is similar to that given pixel.

    This approach was experimentally less succesful than the average pixel mapping algorithm, "make_mosaic_avg"

    Parameters:
        target_photo : filename of target photo (string)
        photos_dir : name of folder of images (string)
        first_run : Boolean if this is the first time this method is being run
            This method includes a time-extensive method which should only be run once per photo_dir
    Returns:
        PIL Image of generated photo mosaic
    """

    #get dictionary mapping each filename to its respective image
    file_image_map = get_file_image_map(photos_dir)
    
    #only run kmeans clustering the first time you do this, so you can use the same set of photos for multiple target images without running this often
    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    #get list of all centroids
    all_centroids = kmeans_dataframe["centroid"].tolist()

    #initialize KD Tree
    nearest_neighbors_tree = KDTree(all_centroids)

    #prep image
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    #loop through each pixel of the target image
    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            #find the 10 photos that have a dominant centroid most near the current pixel
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            
            #generate subset of kmeans_dataframe that includes only the top-10 nearest neighbors
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)

            # pick a random image of the top 10 centroid matches
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            
            #gets the image given the filename
            closest_img = file_image_map[closest_file]

            #add new image object running row image
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
        #add row image object to running column image
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    #return stack of images as one
    return column_image

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50, pixelWidth=50):
    """
    This function takes in a target_photo filename, a photos_dir directory name, the basewidth of pixels for the target image to be reshaped to,
    and the pixelWidth, which is the width of each image replacing each pixel in the resized target image
    """
    #maps filenames to PIL image objects
    file_image_map = get_file_image_map(photos_dir, width = pixelWidth)

    #maps filenames to the file"s average pixel value
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)

    #maps avg pixel values back to filenames
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)

    #array of all average pixels. There should be one element per file.
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    #gets a matrix of all image similarity comparisons, as well as a mapping from filename to index in the matrix. 
    file_index_map, all_distances_matrix = get_all_image_comparisons_matrix(file_image_map)

    #initialize datatype for quick lookup of similar pixels
    nearest_neighbors_tree = KDTree(all_avg_pixels)

    #load and prep image
    img = Image.open(target_photo)
    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    #initialize matrix to be used to check nearby appended images so as to not add a duplicate
    filename_matrix = []

    #basically window size in sliding window algorithm
    min_array_distance_between_similar_photos = 5

    #loop through each pixel of the target image
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            #select 200 nearest neighbors
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 200)[1]
            #loop through sliding window of filenames appended nearby to ensure no similar images are near
            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]
                    neighbor_distance_index = file_index_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4 #this is for debugging to ensure we don"t accidentally recycle this variable in the loop
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_file_index = file_index_map[window_file]
                                            image_distance = all_distances_matrix[neighbor_distance_index][window_file_index]
                                            if image_distance < 85:
                                                isValid = False
                        #if isValid is still true, then set flags to continue out of these loops
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file
            #add image_toAdd to row
            if x == 0:
                row_image = image_toAdd
            else:
                row_image = get_concat_h(row_image, image_toAdd)
            
            #add filename of appended image to filename_matrix
            filename_matrix[y].append(filename_toAdd)
        
        #append row of images to an image of all previous columns
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    #return all columns of images of rows of images appended together
    return column_image


target_photo = "angie_flower.jpeg"
photos_dir = "Photos/"
img = make_mosaic_avg(target_photo, photos_dir, basewidth=60, pixelWidth=200)
img.save("mosaic.jpg")
' --end-code='from PIL import Image
import numpy as np
import os
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans
import pandas as pd

def get_avg_pixel(img):
     """
     Parameters: img (PIL Image object)
     returns: average pixel (RGB tuple)
     """
     resized_image = img.resize((1,1), Image.Resampling.LANCZOS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    """
     Parameters:
        file_image_map : (dictionary mapping filenames to their respective PIL Image objects)
     Returns: 
        dictionary mapping filenames to their average calculated pixel value (RGB tuple)
     """
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        

def get_file_image_map(photos_dir, width=50):
    """
    Parameters:
        photos_dir : name of directory with photos to make mosaic in it (string)
        width: width in pixels to downscale images to for faster processing and uniform shape (int)
    Returns:
        dictionary mapping filenames to their respective PIL images
    """
    height = width #square image
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(width,height))
            img = img.resize((width, height), Image.Resampling.LANCZOS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    """
    Parameters: 
        im1: PIL image
        im2: PIL image
    Returns:
        PIL image of im1 and im2 being concatenated together horizontally, im1 on left side of im2
    """
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    """
    Parameters: 
        im1: PIL image
        im2: PIL image
    Returns:
        PIL image of im1 and im2 being concatenated together vertically, im1 above im2
    """
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    """
    Parameters:
        pixel_map : dictionary mapping filename to average pixel
    Returns:
        dictionary mapping average pixel to a list of filenames with that pixel average
    """
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    """
    Parameters:
        file_image_map: dictionary mapping filenames to PIL images
    Returns:
        array of all pixel values
    """
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    """
    Parameters:
        img: PIL Image
        basewidth: int
    Returns:
        PIL Image rescaled proportionally such that its new base = basewidth
    """
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.Resampling.LANCZOS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    """
    This function performs a kmeans cluster on each image, clustering the array of pixels to identify dominant colors.

    Parameters:
        file_image_map: dictionary mapping filename to respective PIL Image
    Returns:
        Pandas Dataframe linking together:
            filename (string)
            each color cluster centroid (RGB tuple)
            estimated percent of the image falls into that color cluster (float)
    """

    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    """
    Parameters: 
        s : string in format "(a, b, c)" where a, b, and c are RGB values
    Returns:
        RGB tuple in format (R, G, B)
    """
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    """
    Parameters: 
        img1: PIL Image
        img2: PIL Image
    Returns:
        Mean Squared Error between the pixel values of the two images
    """
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    """
    Vectorized comparison of an image to an array of images

    Parameters:
        neighbor_image: PIL Image
        window_imgs: array of PIL Images
    Returns:
        array of MSE distances between neighbor_image and each image of window_imgs
    """
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def get_all_image_comparisons_matrix(file_image_map):
    """
    Generates a matrix of all Mean Squared Errors between every combination of PIL Images.

    Parameters:
        file_image_map : dictionary mapping filename to its respective PIL Image object
    Returns:
        file_index_map : dictionary mapping filename to its index location in the matrix (for quick lookups)
        all_distances : matrix of dimension (num_images X num_images) of all Mean Squared Errors

    """
    file_index_map = {}
    index = 0
    all_distances = []
    for file in file_image_map.keys():
        file_distances = []
        img = file_image_map[file]
        file_index_map[file] = index
        index += 1
        for compare_file in file_image_map.keys():
            compare_image = file_image_map[compare_file]
            distance = compare_image_distance(img, compare_image)
            file_distances.append(distance)
        all_distances.append(file_distances)
    return file_index_map, all_distances

def make_mosaic_kmeans(target_photo, photos_dir="Photos/", first_run = False):
    """
    Generates a photo mosaic image of a target photo given a folder of images.
    This method uses kmeans clustering to extract the top 4 dominant colors of an image, and then
    map each pixel of the target image to an image in photos_dir that includes a high yield of a
    dominant color that is similar to that given pixel.

    This approach was experimentally less succesful than the average pixel mapping algorithm, "make_mosaic_avg"

    Parameters:
        target_photo : filename of target photo (string)
        photos_dir : name of folder of images (string)
        first_run : Boolean if this is the first time this method is being run
            This method includes a time-extensive method which should only be run once per photo_dir
    Returns:
        PIL Image of generated photo mosaic
    """

    #get dictionary mapping each filename to its respective image
    file_image_map = get_file_image_map(photos_dir)
    
    #only run kmeans clustering the first time you do this, so you can use the same set of photos for multiple target images without running this often
    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    #get list of all centroids
    all_centroids = kmeans_dataframe["centroid"].tolist()

    #initialize KD Tree
    nearest_neighbors_tree = KDTree(all_centroids)

    #prep image
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    #loop through each pixel of the target image
    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            #find the 10 photos that have a dominant centroid most near the current pixel
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            
            #generate subset of kmeans_dataframe that includes only the top-10 nearest neighbors
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)

            # pick a random image of the top 10 centroid matches
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            
            #gets the image given the filename
            closest_img = file_image_map[closest_file]

            #add new image object running row image
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
        #add row image object to running column image
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    #return stack of images as one
    return column_image

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50, pixelWidth=50):
    """
    This function takes in a target_photo filename, a photos_dir directory name, the basewidth of pixels for the target image to be reshaped to,
    and the pixelWidth, which is the width of each image replacing each pixel in the resized target image
    """
    #maps filenames to PIL image objects
    file_image_map = get_file_image_map(photos_dir, width = pixelWidth)

    #maps filenames to the file"s average pixel value
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)

    #maps avg pixel values back to filenames
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)

    #array of all average pixels. There should be one element per file.
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    #gets a matrix of all image similarity comparisons, as well as a mapping from filename to index in the matrix. 
    file_index_map, all_distances_matrix = get_all_image_comparisons_matrix(file_image_map)

    #initialize datatype for quick lookup of similar pixels
    nearest_neighbors_tree = KDTree(all_avg_pixels)

    #load and prep image
    img = Image.open(target_photo)
    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    #initialize matrix to be used to check nearby appended images so as to not add a duplicate
    filename_matrix = []

    #basically window size in sliding window algorithm
    min_array_distance_between_similar_photos = 5

    #loop through each pixel of the target image
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            #select 200 nearest neighbors
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 200)[1]
            #loop through sliding window of filenames appended nearby to ensure no similar images are near
            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]
                    neighbor_distance_index = file_index_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4 #this is for debugging to ensure we don"t accidentally recycle this variable in the loop
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_file_index = file_index_map[window_file]
                                            image_distance = all_distances_matrix[neighbor_distance_index][window_file_index]
                                            #arbitrary threshold that has good experimental results
                                            if image_distance < 85:
                                                isValid = False
                        #if isValid is still true, then set flags to continue out of these loops
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file
            #add image_toAdd to row
            if x == 0:
                row_image = image_toAdd
            else:
                row_image = get_concat_h(row_image, image_toAdd)
            
            #add filename of appended image to filename_matrix
            filename_matrix[y].append(filename_toAdd)
        
        #append row of images to an image of all previous columns
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    #return all columns of images of rows of images appended together
    return column_image


basewidth = 60
printer_dpi = 12000
printer_inches = 24
printer_pixels = printer_dpi * printer_inches

pixels_per_row = basewidth
pixelWidth = printer_pixels // pixels_per_row
print(pixelWidth)

target_photo = "angie_flower.jpeg"
photos_dir = "Photos/"

for width in [25, 50, 100, 4800]:
    height = width

    img = Image.open("angie_bed1.jpg")
    img.draft("RGB",(width,height))
    img = img.resize((width, height), Image.Resampling.LANCZOS)

    img2 = Image.open("angie_bed2.jpg")
    img2.draft("RGB",(width,height))
    img2 = img2.resize((width, height), Image.Resampling.LANCZOS)
    print(width, compare_image_distance(img, img2))



exit()
img = make_mosaic_avg(target_photo, photos_dir, basewidth=basewidth, pixelWidth=pixelWidth)
img.save("mosaic_huge.jpg")
' --filename='main.py'>
<p> code content will go here</p>
See related sections in code:<ul>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region1')">def get_avg_pixel(img):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region3')">def get_file_image_map(photos_dir, width=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region9')">def scale_image_to_basewidth(img, basewidth=50):</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region33')">                    window_x_min = max(0, x-min_array_distance_between_similar_photos)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region34')">basewidth = 60</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region35')">pixels_per_row = basewidth</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region37')">for width in [25, 50, 100, 4800]:</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region38')">    img = Image.open(angie_bed1.jpg)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region39')">    img2 = Image.open(angie_bed2.jpg)</li>
<li class='jumpToCode' onclick="openCodeFile('code_Mosaic_main.html', 'region40')">img = make_mosaic_avg(target_photo, photos_dir, basewidth=basewidth, pixelWidth=pixelWidth)</li>
</ul>
</div><button type='button' class='collapsible'>search: what does dpi mean printer;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=2400x1200+dpi&rlz=1C5CHFA_enUS863US865&oq=2400x1200+dpi&aqs=chrome..69i57j0i10i512j0i10i22i30j0i15i22i30j0i22i30i625j0i390l4.6072j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=2400x1200+dpi&rlz=1C5CHFA_enUS863US865&oq=2400x1200+dpi&aqs=chrome..69i57j0i10i512j0i10i22i30j0i15i22i30j0i22i30i625j0i390l4.6072j0j7&sourceid=chrome&ie=UTF-8")'>2400x1200 dpi</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='images/mosaic/screenshot119.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.dpreview.com/forums/thread/3035616' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open visit: https://www.dpreview.com/forums/thread/3035616")'>How much can 2400 x 1200 DPI resolve?: Printers and Printing Forum: Digital Photography Review</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=what+does+dpi+mean+printer&rlz=1C5CHFA_enUS863US865&oq=what+does+dpi+mean+printer&aqs=chrome..69i57j0i390l3.4155j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=what+does+dpi+mean+printer&rlz=1C5CHFA_enUS863US865&oq=what+does+dpi+mean+printer&aqs=chrome..69i57j0i390l3.4155j0j7&sourceid=chrome&ie=UTF-8")'>what does dpi mean printer</a></span></div><hr>
<div class='webImageLongRow'>
</div>
</div>

<button type='button' class='collapsible'>search: HP T830 dimensions;'</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=HP+T830&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzU_JJuOgF_E_mjMrzgeQ3eIZ-0dUw%3A1676669416342&ei=6PHvY-OyFIOkptQP3O-mqAI&ved=0ahUKEwjjxt2nwJ39AhUDkokEHdy3CSUQ4dUDCBA&uact=5&oq=HP+T830&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIHCC4Q5QQQQzIKCAAQsQMQgwEQQzIFCAAQgAQyCAguEIAEEOUEMgUIABCABDIFCAAQgAQyBQgAEIAEMgUIABCABDILCC4Q1AIQgAQQ5QQyBQgAEIAEOgoIABBHENYEELADOg4IABDpBBDtBBCwAxCLAzoECCMQJzoFCAAQkQI6BAguEEM6EQguEIAEELEDEIMBEMcBENEDOgsIABCABBCxAxCDAToOCC4QgAQQsQMQxwEQ0QM6CwguEIAEELEDEIMBOgcIABCxAxBDOgQIABBDOggILhDlBBCRAjoNCC4QsQMQxwEQ0QMQQzoNCC4QsQMQgwEQ5QQQQ0oECEEYAFDjDliyImCfL2gDcAF4AIABgQGIAYcFkgEDNS4ymAEAoAEByAEKuAECwAEB&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=HP+T830&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzU_JJuOgF_E_mjMrzgeQ3eIZ-0dUw%3A1676669416342&ei=6PHvY-OyFIOkptQP3O-mqAI&ved=0ahUKEwjjxt2nwJ39AhUDkokEHdy3CSUQ4dUDCBA&uact=5&oq=HP+T830&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIHCC4Q5QQQQzIKCAAQsQMQgwEQQzIFCAAQgAQyCAguEIAEEOUEMgUIABCABDIFCAAQgAQyBQgAEIAEMgUIABCABDILCC4Q1AIQgAQQ5QQyBQgAEIAEOgoIABBHENYEELADOg4IABDpBBDtBBCwAxCLAzoECCMQJzoFCAAQkQI6BAguEEM6EQguEIAEELEDEIMBEMcBENEDOgsIABCABBCxAxCDAToOCC4QgAQQsQMQxwEQ0QM6CwguEIAEELEDEIMBOgcIABCxAxBDOgQIABBDOggILhDlBBCRAjoNCC4QsQMQxwEQ0QMQQzoNCC4QsQMQgwEQ5QQQQ0oECEEYAFDjDliyImCfL2gDcAF4AIABgQGIAYcFkgEDNS4ymAEAoAEByAEKuAECwAEB&sclient=gws-wiz-serp")'>HP T830</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=HP+T830+dimensions&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVIQuECSGBEUtocyu1g942s8rkdfw%3A1676669451473&ei=C_LvY4u6HLmfptQPi9qw6As&ved=0ahUKEwjL6724wJ39AhW5j4kEHQstDL0Q4dUDCBA&uact=5&oq=HP+T830+dimensions&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIJCAAQFhAeEPEEMgYIABAWEB4yCQgAEBYQHhDxBDIFCAAQhgMyBQgAEIYDMgUIABCGAzoKCAAQRxDWBBCwAzoHCAAQsAMQQzoPCC4Q5QQQyAMQsAMQQxgBOhIILhDHARDRAxDIAxCwAxBDGAE6BwguEOUEEEM6BAgAEEM6CwguENQCEIAEEOUEOgUIABCABDoICC4QgAQQ5QQ6CAgAEBYQHhAKSgQIQRgAUIMGWJIQYI8RaAFwAXgAgAFwiAHbB5IBAzkuMpgBAKABAcgBDcABAdoBBAgBGAg&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener' onclick='logUserAction("history", "open search: https://www.google.com/search?q=HP+T830+dimensions&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVIQuECSGBEUtocyu1g942s8rkdfw%3A1676669451473&ei=C_LvY4u6HLmfptQPi9qw6As&ved=0ahUKEwjL6724wJ39AhW5j4kEHQstDL0Q4dUDCBA&uact=5&oq=HP+T830+dimensions&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIJCAAQFhAeEPEEMgYIABAWEB4yCQgAEBYQHhDxBDIFCAAQhgMyBQgAEIYDMgUIABCGAzoKCAAQRxDWBBCwAzoHCAAQsAMQQzoPCC4Q5QQQyAMQsAMQQxgBOhIILhDHARDRAxDIAxCwAxBDGAE6BwguEOUEEEM6BAgAEEM6CwguENQCEIAEEOUEOgUIABCABDoICC4QgAQQ5QQ6CAgAEBYQHhAKSgQIQRgAUIMGWJIQYI8RaAFwAXgAgAFwiAHbB5IBAzkuMpgBAKABAcgBDcABAdoBBAgBGAg&sclient=gws-wiz-serp")'>HP T830 dimensions</a></span></div><hr>
<div class='webImageLongRow'>
</div>
</div>

</div>