<button type='button' class='collapsible active'>search: testing web extension chrome</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n3_2023-02-15-12_11_47-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://app.endtest.io/guides/docs/how-to-test-chrome-extensions/' target='_blank' rel='noreferrer noopener'>How to test Chrome Extensions Â· Endtest</a></td></tr></tbody></table></div>
<div class='title'><span><a href='https://www.google.com/search?q=testing+web+extension+chrome&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzUSNRWi4I_lL9pIS_hK_o40VxN3Cg%3A1676482857911&ei=KRntY-mSN_eiptQPo82H0A4&ved=0ahUKEwipy96piZj9AhV3kYkEHaPmAeoQ4dUDCBA&uact=5&oq=testing+web+extension+chrome&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAEyBQghEKsCOgoIABBHENYEELADOgcIABCwAxBDOg0IABDkAhDWBBCwAxgBOhIILhDHARDRAxDIAxCwAxBDGAI6FQguEMcBENEDENQCEMgDELADEEMYAjoECCMQJzoECAAQQzoOCC4QgAQQsQMQxwEQ0QM6EQguEIAEELEDEIMBEMcBENEDOgsIABCABBCxAxCDAToQCAAQgAQQFBCHAhCxAxCDAToSCAAQgAQQFBCHAhCxAxCDARAKOgcIABCABBAKOgoIABCABBCxAxAKOgUIABCRAjoHCAAQsQMQQzoGCAAQChBDOgoIABCxAxCDARBDOgkIABCxAxAKEEM6CwguEIAEELEDEIMBOggIABCABBCxAzoFCAAQgAQ6CAgAELEDEJECOgsILhCxAxCDARCRAjoOCC4QsQMQgwEQxwEQrwE6CwguEIAEEMcBEK8BOgoIABCABBAUEIcCOgUILhCABDoICAAQFhAeEAo6CQgAEBYQHhDxBDoGCAAQFhAeOgsIABAWEB4QDxDxBDoHCAAQDRCABDoFCAAQhgM6CwghEBYQHhDxBBAdOggIIRAWEB4QHUoECEEYAEoECEYYAVDVEVjoYmDFZGgGcAF4AIABb4gBtxSSAQQyNy40mAEAoAEByAETwAEB2gEGCAEQARgJ2gEGCAIQARgI&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>testing web extension chrome</a></span></div><hr>
<div class='webImageLongRow'>
</div>

</div>
<button type='button' class='collapsible active'>search: imageio ndimage</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=imageio+python&rlz=1C5CHFA_enUS863US865&oq=imageio+py&aqs=chrome.0.0i20i263i512j69i57j0i20i263i512j0i512l7.3097j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>imageio python</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n12_2023-02-15-14_45_40-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://imageio.readthedocs.io/en/stable/' target='_blank' rel='noreferrer noopener'>Welcome to imageio’s documentation! — imageio 2.25.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n13_2023-02-15-14_45_46-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://imageio.readthedocs.io/en/stable/examples.html#read-an-image-of-a-cat' target='_blank' rel='noreferrer noopener'>Imageio Usage Examples — imageio 2.25.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n14_2023-02-15-14_50_34-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://imageio.readthedocs.io/en/stable/reference/index.html' target='_blank' rel='noreferrer noopener'>API Reference — imageio 2.25.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n15_2023-02-15-14_50_40-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://imageio.readthedocs.io/en/stable/_autosummary/imageio.v3.imread.html#imageio.v3.imread' target='_blank' rel='noreferrer noopener'>imageio.v3.imread — imageio 2.25.1 documentation</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=imageio+ndimage&rlz=1C5CHFA_enUS863US865&oq=imageio+ndimage&aqs=chrome..69i57j33i160.2401j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>imageio ndimage</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n17_2023-02-15-14_51_24-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://imageio.readthedocs.io/en/stable/reference/index.html' target='_blank' rel='noreferrer noopener'>API Reference — imageio 2.25.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n18_2023-02-15-14_52_12-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://imageio.readthedocs.io/en/stable/_autosummary/imageio.v3.imread.html#imageio.v3.imread' target='_blank' rel='noreferrer noopener'>imageio.v3.imread — imageio 2.25.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n19_2023-02-15-14_52_46-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://github.com/imageio/imageio/blob/v2.25.1/imageio/v3.py#L6-L54' target='_blank' rel='noreferrer noopener'>imageio/v3.py at v2.25.1 · imageio/imageio · GitHub</a></td></tr></tbody></table></div>
</div>

</div>
<button type='button' class='collapsible active'>+ # import imageio.v3 as iio
</button>
<div class='content' --start-code='import imageio.v3 as iio

target_photo = "target_photo.jpg"
photo = iio.imread(target_photo)
print(photo.shape)' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image


basewidth = 50
img = Image.open(target_photo)
wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)
print(img[0,0])



#img.save("resized_image.jpg")'>
<p> code content will go here</p>
<button type='button' class='collapsible active'>search: husky clip art</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=dog+clip+art&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzW89e1J4Qr0B_Aazp8ehihlHUq-2Q:1676494977573&source=lnms&tbm=isch&sa=X&ved=2ahUKEwifh-y8tpj9AhXBkokEHS1iB9cQ_AUoAXoECAEQAw&biw=1680&bih=914&dpr=1' target='_blank' rel='noreferrer noopener'>dog clip art</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=husky+clip+art&tbm=isch&ved=2ahUKEwil8--9tpj9AhUA8ckDHdtHDFsQ2-cCegQIABAA&oq=husky+clip+art&gs_lcp=CgNpbWcQAzIFCAAQgAQyBQgAEIAEMgUIABCABDIGCAAQBxAeMgYIABAHEB4yBggAEAcQHjIGCAAQBRAeMgYIABAFEB4yBggAEAgQHjIGCAAQCBAeOgcIABCxAxBDOggIABCABBCxAzoICAAQBRAHEB5QlQlYmg1gmg5oAHAAeACAAUyIAZADkgEBNpgBAKABAaoBC2d3cy13aXotaW1nwAEB&sclient=img&ei=g0jtY-WlLIDip84P24-x2AU&bih=914&biw=1680&rlz=1C5CHFA_enUS863US865' target='_blank' rel='noreferrer noopener'>husky clip art</a></span></div><hr>
<div class='webImageLongRow'>
</div>
</div>
<button type='button' class='collapsible active'>search: house clipart jpg</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=house+clipart+jpeg&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVsexrAbx06nNxyOW3PoWHMgkKB-Q:1676495089748&source=lnms&tbm=isch&sa=X&ved=2ahUKEwjp0arytpj9AhUSkokEHS-CDlgQ_AUoAXoECAEQAw&biw=1680&bih=914&dpr=1' target='_blank' rel='noreferrer noopener'>house clipart jpeg</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=house+clipart+jpg&tbm=isch&rlz=1C5CHFA_enUS863US865&hl=en&sa=X&ved=2ahUKEwi6lrnztpj9AhUz6MkDHa8ND38QBXoECAEQPw&biw=1665&bih=914' target='_blank' rel='noreferrer noopener'>house clipart jpg</a></span></div><hr>
<div class='webImageLongRow'>
</div>
</div>
<button type='button' class='collapsible active'>search: python pil iterate over pixels</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=python+pil+iterate+over+pixels&rlz=1C5CHFA_enUS863US865&oq=python+pil+iterate&aqs=chrome.0.0i512j69i57j0i22i30i625j0i390l2.2481j0j9&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>python pil iterate over pixels</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n32_2023-02-15-15_08_20-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/3971459/how-to-loop-all-image-pixels-and-tell-whether-they-are-black-or-white' target='_blank' rel='noreferrer noopener'>python - How to loop all image pixels and tell whether they are black or white - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n33_2023-02-15-15_08_52-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.geeksforgeeks.org/python-pil-image-resize-method/' target='_blank' rel='noreferrer noopener'>Python PIL | Image.resize() method - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>
</div>
<button type='button' class='collapsible active'>search: fastest way to calculate average color of image in python</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n34_2023-02-15-15_08_57-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://stackoverflow.com/questions/3971459/how-to-loop-all-image-pixels-and-tell-whether-they-are-black-or-white' target='_blank' rel='noreferrer noopener'>python - How to loop all image pixels and tell whether they are black or white - Stack Overflow</a></td></tr></tbody></table></div>
<div class='title'><span><a href='https://www.google.com/search?q=An+image+access+object&rlz=1C5CHFA_enUS863US865&oq=An+image+access+object&aqs=chrome..69i57j33i15i22i29i30j33i22i29i30j33i15i22i29i30i625j33i22i29i30i625.364j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>An image access object</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n36_2023-02-15-15_10_52-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://learn.microsoft.com/en-us/office/vba/api/access.image' target='_blank' rel='noreferrer noopener'>Image object (Access) | Microsoft Learn</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n37_2023-02-15-15_11_04-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/21030459/how-to-iterate-correctly-over-a-pixel-access-object-from-pil' target='_blank' rel='noreferrer noopener'>python - How to iterate correctly over a pixel access object from PIL? - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n38_2023-02-15-15_11_42-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://note.nkmk.me/en/python-opencv-pillow-image-size/' target='_blank' rel='noreferrer noopener'>Get image size (width, height) with Python, OpenCV, Pillow (PIL) | note.nkmk.me</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n39_2023-02-15-15_18_10-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/43111029/how-to-find-the-average-colour-of-an-image-in-python-with-opencv' target='_blank' rel='noreferrer noopener'>How to find the average colour of an image in Python with OpenCV? - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+get+average+color+of+image&rlz=1C5CHFA_enUS863US865&oq=python+get+average+color+of+image&aqs=chrome.0.0i512j69i57.3585j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>python get average color of image</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+get+average+color+of+image+pil&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVvlF7GmE22_gPAwLcxqpTVNvL1uQ%3A1676495886167&ei=DkztY9vFCe-bptQPlJyV6A4&ved=0ahUKEwjbhIzuuZj9AhXvjYkEHRROBe0Q4dUDCBA&uact=5&oq=python+get+average+color+of+image+pil&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAEyBQghEKABOgQIABBHOgkIABAWEB4Q8QQ6BQgAEIYDOgUIIRCrAjoLCCEQFhAeEPEEEB1KBAhBGABKBAhGGABQvQRYggpgwwtoAHACeACAAX-IAZwDkgEDMi4ymAEAoAEByAEIwAEB&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>python get average color of image pil</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n42_2023-02-15-15_18_40-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://note.nkmk.me/en/python-opencv-pillow-image-size/' target='_blank' rel='noreferrer noopener'>Get image size (width, height) with Python, OpenCV, Pillow (PIL) | note.nkmk.me</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n43_2023-02-15-15_18_43-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.google.com/search?q=python+get+average+color+of+image+pil&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVvlF7GmE22_gPAwLcxqpTVNvL1uQ%3A1676495886167&ei=DkztY9vFCe-bptQPlJyV6A4&ved=0ahUKEwjbhIzuuZj9AhXvjYkEHRROBe0Q4dUDCBA&uact=5&oq=python+get+average+color+of+image+pil&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAEyBQghEKABOgQIABBHOgkIABAWEB4Q8QQ6BQgAEIYDOgUIIRCrAjoLCCEQFhAeEPEEEB1KBAhBGABKBAhGGABQvQRYggpgwwtoAHACeACAAX-IAZwDkgEDMi4ymAEAoAEByAEIwAEB&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>python get average color of image pil</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n44_2023-02-15-15_46_49-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://stackoverflow.com/questions/43111029/how-to-find-the-average-colour-of-an-image-in-python-with-opencv' target='_blank' rel='noreferrer noopener'>How to find the average colour of an image in Python with OpenCV? - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=fastest+way+to+calculate+average+color+of+image+in+python&rlz=1C5CHFA_enUS863US865&oq=fastest+way+to+calculate+average+color+of+image+in+python&aqs=chrome..69i57.7960j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>fastest way to calculate average color of image in python</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n46_2023-02-15-15_49_12-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://towardsdatascience.com/finding-most-common-colors-in-python-47ea0767a06a' target='_blank' rel='noreferrer noopener'>Finding the Most Common Colors in Python | by M. Rake Linggar A. | Towards Data Science</a></td></tr></tbody></table></div>
</div>
</div>
</div>
</div>
</div>
<button type='button' class='collapsible active'>+ #img = img.resize((basewidth, hsize), Image.ANTIALIAS)
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image


basewidth = 50
img = Image.open(target_photo)
wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)

image_matrix = img.load()
width, height = img.size

for x in range(width):
    for y in range(height):
        pixel = image_matrix[x,y]
        print(pixel)



#img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image


basewidth = 50
img = Image.open(target_photo)
wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
#img = img.resize((basewidth, hsize), Image.ANTIALIAS)
img = img.resize((1, 1), Image.ANTIALIAS)

image_matrix = img.load()
width, height = img.size

for x in range(width):
    for y in range(height):
        pixel = image_matrix[x,y]



img.save("resized_image.jpg")'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+ import numpy as np
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image


basewidth = 50
img = Image.open(target_photo)
wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
#img = img.resize((basewidth, hsize), Image.ANTIALIAS)
img = img.resize((1, 1), Image.ANTIALIAS)

image_matrix = img.load()
width, height = img.size

for x in range(width):
    for y in range(height):
        pixel = image_matrix[x,y]
        print(pixel)



img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np



basewidth = 50
img = Image.open(target_photo)
wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
#img = img.resize((basewidth, hsize), Image.ANTIALIAS)
img = img.resize((1, 1), Image.ANTIALIAS)

image_matrix = img.load()
width, height = img.size

# arr = []
 for x in range(width):
     for y in range(height):
         pixel = image_matrix[x,y]
         print(pixel)
#         arr.append(list(pixel))

# arr = np.array(arr)
# print(np.mean(arr, axis=0))


img.save("resized_image.jpg")'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+ import os
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np



basewidth = 50
img = Image.open(target_photo)
wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
#img = img.resize((basewidth, hsize), Image.ANTIALIAS)
img = img.resize((1, 1), Image.ANTIALIAS)

image_matrix = img.load()
width, height = img.size

# arr = []
for x in range(width):
     for y in range(height):
         pixel = image_matrix[x,y]
         print(pixel)
#         arr.append(list(pixel))

# arr = np.array(arr)
# print(np.mean(arr, axis=0))


img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

photos_dir = "Photos/"
for filename in os.listdir(photos_dir):
     img = Image.open(photos_dir+filename)
     


img = Image.open(target_photo)
basewidth = 50


# wpercent = (basewidth / float(img.size[0]))
# hsize = int((float(img.size[1]) * float(wpercent)))
# img = img.resize((basewidth, hsize), Image.ANTIALIAS)



# image_matrix = img.load()
# width, height = img.size

# for x in range(width):
#      for y in range(height):
#          pixel = image_matrix[x,y]

# img.save("resized_image.jpg")'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+ #pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl",'wb'))
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle


def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map", "rb"))

img = Image.open(target_photo)
basewidth = 50


# wpercent = (basewidth / float(img.size[0]))
# hsize = int((float(img.size[1]) * float(wpercent)))
# img = img.resize((basewidth, hsize), Image.ANTIALIAS)



# image_matrix = img.load()
# width, height = img.size

# for x in range(width):
#      for y in range(height):
#          pixel = image_matrix[x,y]

# img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle


def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

img = Image.open(target_photo)
basewidth = 50


# wpercent = (basewidth / float(img.size[0]))
# hsize = int((float(img.size[1]) * float(wpercent)))
# img = img.resize((basewidth, hsize), Image.ANTIALIAS)



# image_matrix = img.load()
# width, height = img.size

# for x in range(width):
#      for y in range(height):
#          pixel = image_matrix[x,y]

# img.save("resized_image.jpg")'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>search: python vector similarity</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=python+pixel+similarity&rlz=1C5CHFA_enUS863US865&oq=python+pixel+similarity&aqs=chrome..69i57j0i22i30i625j0i390l4j69i60.2792j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>python pixel similarity</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+vector+similarity&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVCnQ_ffL2i3FxVIHEMUOgPO0vf_w%3A1676498440662&ei=CFbtY43bJ_2hptQP-cWAqAs&ved=0ahUKEwiN_5Www5j9AhX9kIkEHfkiALUQ4dUDCBA&uact=5&oq=python+vector+similarity&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIJCAAQBxAeEPEEMgcIABANEIAEMggIABAIEAcQHjIICAAQCBAHEB4yCwgAEAgQBxAeEPEEMgsIABAIEAcQHhDxBDIJCAAQCBAeEPEEMgkIABAIEB4Q8QQyBQgAEIYDMgUIABCGAzoKCAAQRxDWBBCwAzoLCAAQCBAeEA0Q8QQ6CggAEAgQHhANEA9KBAhBGABKBAhGGABQ-whYsRFg2hJoAnABeACAAWeIAd0DkgEDNS4xmAEAoAEByAEIwAEB&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>python vector similarity</a></span></div><hr>
<div class='webImageLongRow'>
</div>

</div>
<button type='button' class='collapsible active'>search: python kdtree example</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=scipy+spatial&rlz=1C5CHFA_enUS863US865&oq=scipy+spatial&aqs=chrome..69i57j0i512l9.2200j0j9&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>scipy spatial</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n52_2023-02-15-16_01_18-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://docs.scipy.org/doc/scipy/reference/spatial.html' target='_blank' rel='noreferrer noopener'>Spatial algorithms and data structures (scipy.spatial) — SciPy v1.10.1 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n53_2023-02-15-16_01_46-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.html#scipy.spatial.KDTree' target='_blank' rel='noreferrer noopener'>scipy.spatial.KDTree — SciPy v1.10.1 Manual</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+kdtree+example&rlz=1C5CHFA_enUS863US865&oq=python+KDTree+example&aqs=chrome.0.0i512j0i22i30i625j0i22i30j0i22i30i625j0i22i30l2j0i390l4.2374j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>python kdtree example</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n55_2023-02-15-16_04_00-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.query.html' target='_blank' rel='noreferrer noopener'>scipy.spatial.KDTree.query — SciPy v1.10.1 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n56_2023-02-15-16_04_31-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.html#scipy.spatial.KDTree' target='_blank' rel='noreferrer noopener'>scipy.spatial.KDTree — SciPy v1.10.1 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n57_2023-02-15-16_13_31-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.query.html#scipy.spatial.KDTree.query' target='_blank' rel='noreferrer noopener'>scipy.spatial.KDTree.query — SciPy v1.10.1 Manual</a></td></tr></tbody></table></div>
</div>

<button type='button' class='collapsible active'>+ from scipy.spatial import KDTree</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle


def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    filename_map[avg_pixel_value] = filename


print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


# wpercent = (basewidth / float(img.size[0]))
# hsize = int((float(img.size[1]) * float(wpercent)))
# img = img.resize((basewidth, hsize), Image.ANTIALIAS)



# image_matrix = img.load()
# width, height = img.size

# for x in range(width):
#      for y in range(height):
#          pixel = image_matrix[x,y]

# img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

for x in range(width):
     for y in range(height):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        print(nearest_neighbors)
#img.save("resized_image.jpg")'>
<p> code content will go here</p>
</div></div>
<button type='button' class='collapsible active'>search: pil image draft</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=RGB+(177%2C+182%2C+182)&rlz=1C5CHFA_enUS863US865&oq=RGB+(177%2C+182%2C+182)&aqs=chrome..69i57j0i546l3j0i30i546.2345j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>RGB (177, 182, 182)</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n59_2023-02-15-16_22_59-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://convertingcolors.com/rgb-color-177_182_182.html' target='_blank' rel='noreferrer noopener'>Converting Colors - RGB - 177, 182, 182</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=pil+update+pixel&rlz=1C5CHFA_enUS863US865&oq=pil+update+pixel&aqs=chrome..69i57j33i160l4.3009j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>pil update pixel</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n61_2023-02-15-16_33_55-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/36468530/changing-pixel-color-value-in-pil' target='_blank' rel='noreferrer noopener'>python - Changing pixel color value in PIL - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n62_2023-02-15-16_36_44-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.geeksforgeeks.org/python-pil-putpixel-method/' target='_blank' rel='noreferrer noopener'>Python PIL | putpixel() method - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=pil+append+images&rlz=1C5CHFA_enUS863US865&oq=pil+append+images&aqs=chrome..69i57j0i22i30i625l3j0i390l4.2623j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>pil append images</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n64_2023-02-15-16_41_05-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://note.nkmk.me/en/python-pillow-concat-images/' target='_blank' rel='noreferrer noopener'>Concatenate images with Python, Pillow | note.nkmk.me</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=pil+read+in+images+faster&rlz=1C5CHFA_enUS863US865&oq=pil+read+in+images+faster&aqs=chrome..69i57j33i160.3959j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>pil read in images faster</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n66_2023-02-15-17_17_12-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/57663734/how-to-speed-up-image-loading-in-pillow-python' target='_blank' rel='noreferrer noopener'>How to speed up image loading in pillow (python)? - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=pil+image+draft&rlz=1C5CHFA_enUS863US865&oq=pil+image+draft&aqs=chrome..69i57j0i390l5.1921j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>pil image draft</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n68_2023-02-15-17_18_44-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.geeksforgeeks.org/python-pil-image-draft-method/' target='_blank' rel='noreferrer noopener'>Python PIL | Image.draft() method - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>

<button type='button' class='collapsible active'>+         #print(pixel, closest_file)</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

for x in range(width):
     for y in range(height):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel]
        print(pixel, closest_file)

#img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

for x in range(width):
     for y in range(height):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel]
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel

img.save("recolored_image.jpg")
#img.save("resized_image.jpg")'>
<p> code content will go here</p>
</div><button type='button' class='collapsible active'>+ for y in range(height):</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

for x in range(width):
     for y in range(height):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel]
        
        #closest_img = Image.open(photos_dir+closest_file).resize((50, 50), Image.ANTIALIAS)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
        if y == 0:
            image_matrix[x,y] = (0,0,0)


img.save("recolored_image.jpg")
#img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        print(closest_file)
        closest_img = Image.open(photos_dir+closest_file).resize((50, 50), Image.ANTIALIAS)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
        


img.save("recolored_image.jpg")
#img.save("resized_image.jpg")'>
<p> code content will go here</p>
</div><button type='button' class='collapsible active'>+ target_photo = "target_angie.jpg"</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "house.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_all_images(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            file_image_map[filename] = img
    return file_image_map

file_image_map = get_all_images(photos_dir)
pickle.dump(file_image_map, open("file_image_map.pkl","wb"))

file_image_map = pickle.load(open("file_image_map.pkl","rb"))

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
        


img.save("recolored_image.jpg")
#img.save("resized_image.jpg")' --end-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_all_images(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

print("generating map")
file_image_map = get_all_images(photos_dir)
print("map generated")
#pickle.dump(file_image_map, open("file_image_map.pkl","wb"))
print("pickled")

#file_image_map = pickle.load(open("file_image_map.pkl","rb"))

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 100


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((100, 100), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

'>
<p> code content will go here</p>
</div></div>
<button type='button' class='collapsible active'>revisit: Python PIL | Image.draft() method - GeeksforGeeks</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n70_2023-02-15-17_19_16-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.geeksforgeeks.org/python-pil-image-draft-method/' target='_blank' rel='noreferrer noopener'>Python PIL | Image.draft() method - GeeksforGeeks</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n71_2023-02-15-21_19_53-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://note.nkmk.me/en/python-opencv-pillow-image-size/' target='_blank' rel='noreferrer noopener'>Get image size (width, height) with Python, OpenCV, Pillow (PIL) | note.nkmk.me</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n72_2023-02-16-10_50_33-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.geeksforgeeks.org/python-pil-image-draft-method/' target='_blank' rel='noreferrer noopener'>Python PIL | Image.draft() method - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>

<button type='button' class='collapsible active'>+ target_photo = "target_angie.jpg"</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_me.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]


photos_dir = "Photos/"

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_all_images(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

print("generating map")
file_image_map = get_all_images(photos_dir)
print("map generated")
#pickle.dump(file_image_map, open("file_image_map.pkl","wb"))
print("pickled")

#file_image_map = pickle.load(open("file_image_map.pkl","rb"))

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 100


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)



image_matrix = img.load()
width, height = img.size

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((100, 100), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_all_images(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst


print("generating map")
file_image_map = get_all_images(photos_dir)
print("map generated")
#pickle.dump(file_image_map, open("file_image_map.pkl","wb"))
print("pickled")

#file_image_map = pickle.load(open("file_image_map.pkl","rb"))

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)


image_matrix = img.load()
width, height = img.size


for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div></div>
<button type='button' class='collapsible active'>+ def get_file_avgPixelMap(file_image_map):
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_all_avg_pixels(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_all_images(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst


print("generating map")
file_image_map = get_all_images(photos_dir)
print("map generated")
#pickle.dump(file_image_map, open("file_image_map.pkl","wb"))
print("pickled")

#file_image_map = pickle.load(open("file_image_map.pkl","rb"))

#pickle.dump(get_all_avg_pixels(photos_dir), open("photo_pixel_map.pkl","wb"))
pixel_map = get_all_avg_pixels(photos_dir)#pickle.load(open("photo_pixel_map.pkl", "rb"))

filename_map = {}
#create map from pixel value to list of files with that avg pixel
for filename in pixel_map.keys():
    avg_pixel_value = pixel_map[filename]
    if avg_pixel_value in filename_map.keys():
        filename_map[avg_pixel_value].append(filename)
    else:
        filename_map[avg_pixel_value] = [filename]

#print(filename_map.keys())

all_pixels = []
for filename in pixel_map.keys():
    all_pixels.append(pixel_map[filename])

tree = KDTree(all_pixels)


#print(pixel_map["IMG_20200915_132507.jpg"])
img = Image.open(target_photo)
basewidth = 50


wpercent = (basewidth / float(img.size[0]))
hsize = int((float(img.size[1]) * float(wpercent)))
img = img.resize((basewidth, hsize), Image.ANTIALIAS)


image_matrix = img.load()
width, height = img.size


for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_pixels[pixel_index]
        closest_file = filename_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
            pixel = get_avg_pixel(img)
            file_avgPixel_map[file] = pixel
        except:
            print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels


file_image_map = get_file_image_map(photos_dir)

file_avgPixel_map = get_file_avgPixelMap(file_image_map)#pickle.load(open("photo_pixel_map.pkl", "rb"))

pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(pixel_files_map)

tree = KDTree(all_avg_pixels)


img = Image.open(target_photo)

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+         return img.load()[0,0]
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        img.draft("RGB", (1,1))
        try:
            pixel = get_avg_pixel(img)
            file_avgPixel_map[file] = pixel
        except:
            print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels



def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        img.draft("RGB", (1,1))
        return img.load()[0,0]
        # try:
        #     pixel = get_avg_pixel(img)
        #     file_avgPixel_map[file] = pixel
        # except:
        #     print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels



def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+         try:
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        img.draft("RGB", (1,1))
        file_avgPixel_map[file] = img.load()[0,0]
        # try:
        #     pixel = get_avg_pixel(img)
        #     file_avgPixel_map[file] = pixel
        # except:
        #     print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels



def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 1)
        pixel_index = nearest_neighbors[1]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[0][1]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+         pixel_index = nearest_neighbors[1][9]
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        print(nearest_neighbors)
        pixel_index = nearest_neighbors[0][1]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][9]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+ target_photo = "colorwheel.jpeg"
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        #print(closest_file)
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        #print(pixel, closest_file)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")
        


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "colorwheel.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
        image_matrix[x,y] = np.mean([pixel, neighbor_pixel],axis=0)
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
<button type='button' class='collapsible active'>search: python find dominant color in image</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=color+wheel+jpg&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzXQu_fpTAkmqbBy3kVS2tJdbTBc7A:1676570731091&source=lnms&tbm=isch&sa=X&ved=2ahUKEwj8-PfW0Jr9AhVZkYkEHSkcBlgQ_AUoAXoECAEQAw&biw=1680&bih=914&dpr=1' target='_blank' rel='noreferrer noopener'>color wheel jpg</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+convert+image+to+jpg&rlz=1C5CHFA_enUS863US865&oq=python+convert+image+to+jpg&aqs=chrome..69i57j0i22i30i625j0i22i30j0i22i30i625l7.3722j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>python convert image to jpg</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n79_2023-02-16-12_07_39-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.geeksforgeeks.org/convert-an-image-into-jpg-format-using-pillow-in-python/' target='_blank' rel='noreferrer noopener'>Convert an image into jpg format using Pillow in Python - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+find+dominant+color+in+image&rlz=1C5CHFA_enUS863US865&oq=python+find+dominant+color+&aqs=chrome.0.0i512j69i57j0i22i30i625j0i15i22i30i625j0i22i30j0i390.3600j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>python find dominant color in image</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n81_2023-02-16-12_17_24-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/3241929/python-find-dominant-most-common-color-in-an-image' target='_blank' rel='noreferrer noopener'>Python - Find dominant/most common color in an image - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n82_2023-02-16-12_18_00-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://github.com/fengsp/color-thief-py' target='_blank' rel='noreferrer noopener'>GitHub - fengsp/color-thief-py: Grabs the dominant color or a representative color palette from an image. Uses Python and Pillow.</a></td></tr></tbody></table></div>
</div>
</div>
<button type='button' class='collapsible active'>search: kmeans pil image</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n84_2023-02-16-12_19_09-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://github.com/fengsp/color-thief-py' target='_blank' rel='noreferrer noopener'>GitHub - fengsp/color-thief-py: Grabs the dominant color or a representative color palette from an image. Uses Python and Pillow.</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n85_2023-02-16-12_33_40-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/10016352/convert-numpy-array-to-tuple' target='_blank' rel='noreferrer noopener'>python - Convert numpy array to tuple - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n86_2023-02-16-12_35_45-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.statology.org/numpy-array-to-int/' target='_blank' rel='noreferrer noopener'>How to Convert NumPy Array of Floats into Integers - Statology</a></td></tr></tbody></table></div>
<div class='title'><span><a href='https://www.google.com/search?q=python+blend+image+with+pixel+color&rlz=1C5CHFA_enUS863US865&oq=python+blend+image+with+pixel+color&aqs=chrome..69i57j33i160.8551j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>python blend image with pixel color</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n88_2023-02-16-12_40_39-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://blog.finxter.com/five-useful-image-processing-techniques-in-python-using-opencv/' target='_blank' rel='noreferrer noopener'>Temporary Page</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n89_2023-02-16-12_52_10-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener'>sklearn.cluster.KMeans — scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=kmeans+pil+image&rlz=1C5CHFA_enUS863US865&oq=kmeans+pil+image&aqs=chrome..69i57j0i22i30i625j0i390l4.2711j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>kmeans pil image</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n91_2023-02-16-12_54_08-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/69640278/how-to-usekmeans-parameter-in-pillow-image-quantize' target='_blank' rel='noreferrer noopener'>python - How to use`kmeans` parameter in Pillow Image.quantize? - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n92_2023-02-16-12_54_57-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.geeksforgeeks.org/python-pil-image-quantize-method/' target='_blank' rel='noreferrer noopener'>Python PIL | Image.quantize() method - GeeksforGeeks</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n93_2023-02-16-12_55_43-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener'>sklearn.cluster.KMeans — scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n94_2023-02-16-12_58_17-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/1109422/getting-list-of-pixel-values-from-pil' target='_blank' rel='noreferrer noopener'>python - Getting list of pixel values from PIL - Stack Overflow</a></td></tr></tbody></table></div>
</div>
</div>
</div>
</div>
</div>
<button type='button' class='collapsible active'>+         closest_width, closest_height = closest_img.size
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "colorwheel.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        closest_img_mat = closest_img_resized.load()
        closest_width, closest_height = closest_img_mat.size
        for i in range(closest_height):
            for j in range(closest_width):
                closest_img_pixel = closest_img_mat[j,i]
                print(np.mean([closest_img_pixel, pixel], axis=0))
                closest_img_mat[j,i] = np.mean([closest_img_pixel, pixel], axis=0).totuple()
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "colorwheel.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        closest_img_mat = closest_img_resized.load()
        closest_width, closest_height = closest_img.size
        for i in range(closest_height):
            for j in range(closest_width):
                closest_img_pixel = closest_img_mat[i,j]
                blended_pixel = tuple(np.mean([closest_img_pixel, pixel], axis=0).astype(int))
                print(blended_pixel)
                closest_img_mat[j,i] = blended_pixel
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+ target_photo = "target_angie.jpg"
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "target_angie.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
pixels = img.getdata()
print(pixels)



exit()
file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
pixels = img.getdata()
print(pixels)



exit()
file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>search: python kmeans most dominant color</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=Segmentation+fault%3A+11&rlz=1C5CHFA_enUS863US865&oq=Segmentation+fault%3A+11&aqs=chrome..69i57.557j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>Segmentation fault: 11</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=Segmentation+fault%3A+11+every+other+time+i+run+python+kmeans&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVnkPFAxYemexMisFKcTdJTnmBo_A%3A1676578314267&ei=Co7uY6_nD8CnptQP6_2JgAs&ved=0ahUKEwivlPD27Jr9AhXAk4kEHet-ArAQ4dUDCBA&uact=5&oq=Segmentation+fault%3A+11+every+other+time+i+run+python+kmeans&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAE6CggAEEcQ1gQQsAM6BAgjECc6BAgAEEM6BQgAEIAEOgYIABAWEB46BQgAEIYDOggIIRAWEB4QHToFCCEQqwI6CwghEBYQHhDxBBAdSgQIQRgAULIEWN8_YKFKaAlwAXgAgAF6iAHXHJIBBTE4LjE5mAEAoAEByAEIwAEB&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>Segmentation fault: 11 every other time i run python kmeans</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n98_2023-02-16-14_12_24-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://github.com/scikit-learn/scikit-learn/issues/23574' target='_blank' rel='noreferrer noopener'>Segmentation Fault in KMeans on OSX · Issue #23574 · scikit-learn/scikit-learn · GitHub</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n99_2023-02-16-14_16_04-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://lightrun.com/answers/scikit-learn-scikit-learn-segmentation-fault-in-kmeans-on-osx' target='_blank' rel='noreferrer noopener'>Segmentation Fault in KMeans on OSX</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=sklearn+kmeans+segfault&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzV8bsNpLGVAaej5lujlLmXPVvCBNw%3A1676578338813&ei=Io7uY6WJMaWbptQPgoGgiAo&ved=0ahUKEwilosqC7Zr9AhWljYkEHYIACKEQ4dUDCBA&uact=5&oq=sklearn+kmeans+segfault&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzILCAAQFhAeEPEEEAoyBQgAEIYDMgUIABCGAzIFCAAQhgMyBQgAEIYDOgcIIxCwAxAnOgoIABBHENYEELADOgQIIxAnOgQIABBDOgUIABCRAjoECC4QQzoRCC4QgwEQxwEQsQMQ0QMQgAQ6DgguEIAEELEDEMcBENEDOgsILhCABBDHARDRAzoKCAAQsQMQgwEQQzoLCAAQsQMQgwEQkQI6CwgAEIAEELEDEIMBOgoIABCABBAUEIcCOhAIABCABBAUEIcCELEDEIMBOgcIABCxAxBDOggIABCABBCxAzoFCAAQgAQ6CQgAEBYQHhDxBDoFCCEQoAFKBAhBGABQ_ghY7CVg5yZoBXAAeACAAW6IAcQQkgEEMjIuM5gBAKABAcgBCcABAQ&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>sklearn kmeans segfault</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n101_2023-02-16-14_16_40-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/35973698/python-memory-error-for-kmeans-in-scikit-learn' target='_blank' rel='noreferrer noopener'>c++ - python memory error for kmeans in scikit-learn - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=mac+check+memory+usage&rlz=1C5CHFA_enUS863US865&oq=mac+check+memory+usage&aqs=chrome.0.0i512l4j0i22i30i625l6.2743j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>mac check memory usage</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n103_2023-02-16-14_20_11-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.google.com/search?q=sklearn+kmeans+segfault&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzV8bsNpLGVAaej5lujlLmXPVvCBNw%3A1676578338813&ei=Io7uY6WJMaWbptQPgoGgiAo&ved=0ahUKEwilosqC7Zr9AhWljYkEHYIACKEQ4dUDCBA&uact=5&oq=sklearn+kmeans+segfault&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzILCAAQFhAeEPEEEAoyBQgAEIYDMgUIABCGAzIFCAAQhgMyBQgAEIYDOgcIIxCwAxAnOgoIABBHENYEELADOgQIIxAnOgQIABBDOgUIABCRAjoECC4QQzoRCC4QgwEQxwEQsQMQ0QMQgAQ6DgguEIAEELEDEMcBENEDOgsILhCABBDHARDRAzoKCAAQsQMQgwEQQzoLCAAQsQMQgwEQkQI6CwgAEIAEELEDEIMBOgoIABCABBAUEIcCOhAIABCABBAUEIcCELEDEIMBOgcIABCxAxBDOggIABCABBCxAzoFCAAQgAQ6CQgAEBYQHhDxBDoFCCEQoAFKBAhBGABQ_ghY7CVg5yZoBXAAeACAAW6IAcQQkgEEMjIuM5gBAKABAcgBCcABAQ&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>sklearn kmeans segfault</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n104_2023-02-16-14_20_15-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://stackoverflow.com/questions/35973698/python-memory-error-for-kmeans-in-scikit-learn' target='_blank' rel='noreferrer noopener'>c++ - python memory error for kmeans in scikit-learn - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n105_2023-02-16-14_21_52-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://github.com/scikit-learn/scikit-learn/issues/23574' target='_blank' rel='noreferrer noopener'>Segmentation Fault in KMeans on OSX · Issue #23574 · scikit-learn/scikit-learn · GitHub</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+kmeans+most+dominant+color&rlz=1C5CHFA_enUS863US865&oq=python+kmeans+most+dominant+color&aqs=chrome..69i57j33i160.5078j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>python kmeans most dominant color</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n107_2023-02-16-14_25_41-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://medium.com/buzzrobot/dominant-colors-in-an-image-using-k-means-clustering-3c7af4622036' target='_blank' rel='noreferrer noopener'>Dominant colors in an image using k-means clustering | by Shivam Thakkar | buZZrobot | Medium</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n108_2023-02-16-14_33_29-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener'>sklearn.cluster.KMeans — scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
</div>

<button type='button' class='collapsible active'>+ kmeans = KMeans(n_clusters=15).fit(pixels)</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
img = scale_image_to_basewidth(img, basewidth=50)

pixels = np.array(img.getdata())

print(pixels.shape)

print("doing kmeans")
for i in range(10):
    kmeans = KMeans(n_clusters=5).fit(pixels)
print(kmeans)

print(len(pixels))



exit()
file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "target_angie.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
img = scale_image_to_basewidth(img, basewidth=50)

pixels = np.array(img.getdata())

print(pixels.shape)

print("doing kmeans")
kmeans = KMeans(n_clusters=15).fit(pixels)
print(kmeans.cluster_centers_.astype(int))

print(len(pixels))



exit()
file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div></div>
<button type='button' class='collapsible active'>search: rgb 111  58  51</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=159+155+145&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVeJzMui1qfxImi4KPl4_em2DrXIg%3A1676579777063&ei=wZPuY7y-A6K6qtsPz5askA0&ved=0ahUKEwj8orKw8pr9AhUinWoFHU8LC9IQ4dUDCBA&uact=5&oq=159+155+145&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzoKCAAQRxDWBBCwA0oECEEYAFD7DFj7DGCgEWgDcAF4AIABUYgBUZIBATGYAQCgAQKgAQHIAQXAAQE&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>159 155 145</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=rgb+159+155+145&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVTW6tdbpkulDuxBxJljMjHFCScyQ%3A1676579826081&ei=8pPuY_GsBLqeqtsP0uSO-AY&ved=0ahUKEwjx7eHH8pr9AhU6j2oFHVKyA28Q4dUDCBA&uact=5&oq=rgb+159+155+145&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCAAQogQyBQgAEKIEMgUIABCiBDIFCAAQogQ6BwgAEB4QogRKBAhBGAFQ-gNYgglg0gxoAXAAeACAAVeIAc0CkgEBNJgBAKABAcABAQ&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>rgb 159 155 145</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=rgb+75+102++69&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVPEpL8emeklswriOwzmCxu7RgTDQ%3A1676579834540&ei=-pPuY8TOIKmxqtsPr--i0Ak&ved=0ahUKEwjEs-bL8pr9AhWpmGoFHa-3CJoQ4dUDCBA&uact=5&oq=rgb+75+102++69&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCAAQogQyBwgAEB4QogQyBQgAEKIEOgoIABBHENYEELADOgQIIxAnOgUIABCRAjoECAAQQzoICC4Q1AIQkQI6CAguELEDEIMBOgUIABCABDoECAAQAzoHCAAQsQMQQzoKCAAQsQMQgwEQQzoRCC4QgAQQsQMQgwEQxwEQ0QM6DQgAEIAEEBQQhwIQsQM6CAgAEIAEELEDOgsIABCABBCxAxCDAUoECEEYAFDGC1iTE2CTFmgDcAF4AIABbIgB6gOSAQMzLjKYAQCgAQGgAQLIAQbAAQE&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>rgb 75 102  69</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=rgb+111++58++51&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzUFwV4hlzPp7uNBMTQZlti5SouhDg%3A1676580106321&ei=CpXuY_qUE6u1ptQPzfK_8Ak&ved=0ahUKEwj6wbLN85r9AhWrmokEHU35D54Q4dUDCBA&uact=5&oq=rgb+111++58++51&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCAAQogQyCggAEPEEEB4QogQyBQgAEKIEMgUIABCiBDoKCAAQRxDWBBCwA0oECEEYAFC-BVi-BWC8B2gBcAB4AIABc4gBc5IBAzAuMZgBAKABAqABAcgBB8ABAQ&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>rgb 111  58  51</a></span></div><hr>
<div class='webImageLongRow'>
</div>

<button type='button' class='collapsible active'>+ target_photo = "angie_flower.jpeg"</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_redleaves.jpg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
img = scale_image_to_basewidth(img, basewidth=50)

pixels = np.array(img.getdata())

print(pixels.shape)

print("doing kmeans")
kmeans = KMeans(n_clusters=15).fit(pixels)
print(kmeans.cluster_centers_.astype(int))

print(len(pixels))



exit()
file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
img = scale_image_to_basewidth(img, basewidth=50)

pixels = np.array(img.getdata())

print(pixels.shape)

print("doing kmeans")

kmeans = KMeans(n_clusters=4).fit(pixels)
print(kmeans.cluster_centers_.astype(int))

print(len(pixels))
predictions = kmeans.predict(pixels)
print(np.unique(predictions, return_counts = True))


exit()
file_image_map = get_file_image_map(photos_dir)
file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div></div>
<button type='button' class='collapsible active'>revisit: Dominant colors in an image using k-means clustering | by Shivam Thakkar | buZZrobot | Medium</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n114_2023-02-16-14_42_52-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener'>sklearn.cluster.KMeans — scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n115_2023-02-16-14_43_17-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://medium.com/buzzrobot/dominant-colors-in-an-image-using-k-means-clustering-3c7af4622036' target='_blank' rel='noreferrer noopener'>Dominant colors in an image using k-means clustering | by Shivam Thakkar | buZZrobot | Medium</a></td></tr></tbody></table></div>
</div>

</div>
<button type='button' class='collapsible active'>search: python show color</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n117_2023-02-16-14_43_31-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://medium.com/buzzrobot/dominant-colors-in-an-image-using-k-means-clustering-3c7af4622036' target='_blank' rel='noreferrer noopener'>Dominant colors in an image using k-means clustering | by Shivam Thakkar | buZZrobot | Medium</a></td></tr></tbody></table></div>
<div class='title'><span><a href='https://www.google.com/search?q=python+show+color&rlz=1C5CHFA_enUS863US865&oq=python+show+color&aqs=chrome..69i57j0i512l2j0i22i30i625l7.2817j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>python show color</a></span></div><hr>
<div class='webImageLongRow'>
</div>

</div>
<button type='button' class='collapsible active'>search: rgb 105 112  7</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=rgb+211+169+13&rlz=1C5CHFA_enUS863US865&oq=rgb+211+169++13&aqs=chrome..69i57j0i30i546j0i546.1601j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>rgb 211 169 13</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=rgb+105+112++7&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVnN2KhHjxdmcXCmP6QocV_S2a2KA%3A1676580479854&ei=f5buY8rkM4alptQPgOyD8Ag&ved=0ahUKEwiKoMH_9Jr9AhWGkokEHQD2AI4Q4dUDCBA&uact=5&oq=rgb+105+112++7&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQqwIyDQghEBYQHhAPEPEEEB06CggAEEcQ1gQQsANKBAhBGABQ4wVY4wVgvQhoAXABeACAAWaIAWaSAQMwLjGYAQCgAQKgAQHIAQbAAQE&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>rgb 105 112  7</a></span></div><hr>
<div class='webImageLongRow'>
</div>

</div>
<button type='button' class='collapsible active'>search: kmeans number in cluster</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n124_2023-02-16-14_48_22-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://github.com/scikit-learn/scikit-learn/issues/23574' target='_blank' rel='noreferrer noopener'>Segmentation Fault in KMeans on OSX · Issue #23574 · scikit-learn/scikit-learn · GitHub</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n125_2023-02-16-14_48_44-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener'>sklearn.cluster.KMeans — scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
<div class='title'><span><a href='https://www.google.com/search?q=kmeans+number+in+cluster&rlz=1C5CHFA_enUS863US865&oq=kmeans+number+in+cluster&aqs=chrome..69i57j0i22i30i625j0i22i30j0i22i30i625j0i390l3.3849j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>kmeans number in cluster</a></span></div><hr>
<div class='webImageLongRow'>
</div>

</div>
<button type='button' class='collapsible active'>revisit: Convert an image into jpg format using Pillow in Python - GeeksforGeeks</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n129_2023-02-16-15_04_06-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://github.com/fengsp/color-thief-py' target='_blank' rel='noreferrer noopener'>GitHub - fengsp/color-thief-py: Grabs the dominant color or a representative color palette from an image. Uses Python and Pillow.</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n130_2023-02-16-15_04_13-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.geeksforgeeks.org/convert-an-image-into-jpg-format-using-pillow-in-python/' target='_blank' rel='noreferrer noopener'>Convert an image into jpg format using Pillow in Python - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>

</div>
<button type='button' class='collapsible active'>search: k means predict probability sklearn</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n135_2023-02-16-15_04_40-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://towardsdatascience.com/finding-most-common-colors-in-python-47ea0767a06a' target='_blank' rel='noreferrer noopener'>Finding the Most Common Colors in Python | by M. Rake Linggar A. | Towards Data Science</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n136_2023-02-16-15_05_43-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://scikit-learn.org/stable/modules/clustering.html' target='_blank' rel='noreferrer noopener'>2.3. Clustering — scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n137_2023-02-16-15_06_19-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.OPTICS.html#sklearn.cluster.OPTICS' target='_blank' rel='noreferrer noopener'>sklearn.cluster.OPTICS — scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
<div class='title'><span><a href='https://www.google.com/search?q=best+clustering+algorithm+for+pixel+data&rlz=1C5CHFA_enUS863US865&oq=best+clustering+algorithm+for+pixel+data&aqs=chrome..69i57j33i160l4.4872j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>best clustering algorithm for pixel data</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n139_2023-02-16-15_10_52-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.google.com/search?q=kmeans+number+in+cluster&rlz=1C5CHFA_enUS863US865&oq=kmeans+number+in+cluster&aqs=chrome..69i57j0i22i30i625j0i22i30j0i22i30i625j0i390l3.3849j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>kmeans number in cluster</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n140_2023-02-16-15_12_42-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener'>sklearn.cluster.KMeans — scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=k+means+predict+probability&rlz=1C5CHFA_enUS863US865&oq=k+means+predict+probability&aqs=chrome..69i57j33i160j33i299l2j33i22i29i30.2984j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>k means predict probability</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n142_2023-02-16-15_15_01-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://datascience.stackexchange.com/questions/14435/how-to-get-the-probability-of-belonging-to-clusters-for-k-means' target='_blank' rel='noreferrer noopener'>python - How to get the probability of belonging to clusters for k-means? - Data Science Stack Exchange</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=k+means+predict+probability+sklearn&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzVCEg8BXyZmHbKt1guKLJIskG0BPQ%3A1676582097169&ei=0ZzuY7LrCY6bptQPrOOZ-Ao&ved=0ahUKEwjyl9qC-5r9AhWOjYkEHaxxBq8Q4dUDCBA&uact=5&oq=k+means+predict+probability+sklearn&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAE6CggAEEcQ1gQQsAM6BQghEKsCOggIIRAWEB4QHToKCCEQFhAeEA8QHToLCCEQFhAeEPEEEB1KBAhBGABQ6QJYmwhg4AhoAXAAeACAAZEBiAGkBpIBAzIuNZgBAKABAcgBCMABAQ&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>k means predict probability sklearn</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n144_2023-02-16-15_15_49-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener'>sklearn.cluster.KMeans — scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
</div>

</div>
<button type='button' class='collapsible active'>search: pandas column of tuples becomes string</button>
<div class='content'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n146_2023-02-16-15_25_51-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html' target='_blank' rel='noreferrer noopener'>sklearn.cluster.KMeans — scikit-learn 1.2.1 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n147_2023-02-16-16_42_20-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.google.com/search?q=kmeans+number+in+cluster&rlz=1C5CHFA_enUS863US865&oq=kmeans+number+in+cluster&aqs=chrome..69i57j0i22i30i625j0i22i30j0i22i30i625j0i390l3.3849j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>kmeans number in cluster</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n148_2023-02-16-16_55_49-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/61589488/convert-a-column-in-a-dataframe-from-type-string-to-tuple' target='_blank' rel='noreferrer noopener'>python - Convert a column in a dataframe from type string to tuple - Stack Overflow</a></td></tr></tbody></table></div>
<div class='title'><span><a href='https://www.google.com/search?q=pandas+string+to+tuple&rlz=1C5CHFA_enUS863US865&oq=pandas+string+to+tuple&aqs=chrome..69i57j0i22i30i625l6j0i22i30l2j0i22i30i625.2524j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>pandas string to tuple</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n150_2023-02-16-16_56_10-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.geeksforgeeks.org/python-convert-string-to-tuple/' target='_blank' rel='noreferrer noopener'>Python | Convert String to Tuple - GeeksforGeeks</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=pandas+column+of+tuples+becomes+string&rlz=1C5CHFA_enUS863US865&oq=pandas+column+of+tuples+becomes+string&aqs=chrome..69i57j33i160.6440j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>pandas column of tuples becomes string</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n152_2023-02-16-16_57_59-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/65409122/python-pandas-convert-a-column-of-tuples-to-string-column' target='_blank' rel='noreferrer noopener'>python pandas - Convert a column of tuples to string column - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n153_2023-02-16-16_58_11-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://www.google.com/search?q=pandas+column+of+tuples+becomes+string&rlz=1C5CHFA_enUS863US865&oq=pandas+column+of+tuples+becomes+string&aqs=chrome..69i57j33i160.6440j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>pandas column of tuples becomes string</a></td></tr></tbody></table></div>
</div>

<button type='button' class='collapsible active'>+     all_rows = []</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
img = scale_image_to_basewidth(img, basewidth=50)

def get_kmeans_dataframe_image(img):
    pixels = np.array(img.getdata())
    kmeans = KMeans(n_clusters=4).fit(pixels)
    centroids = kmeans.cluster_centers_.astype(int)
    table_columns = ["filename","centroid","percent"]

    all_rows = []

    predictions = kmeans.predict(pixels)
    centroid_indexes, counts = np.unique(predictions, return_counts = True)
    percentages = counts / counts.sum()
    for percent, centroid in zip(percentages, centroids):
        #skip if percent < threshold
        print(tuple(centroid), percent)
        all_rows.append([target_photo, tuple(centroid), percent])

    df = pd.DataFrame(all_rows, columns=table_columns)
    return df

def get_kmeans_dataframe_all_photos(file_image_map):
    return pd.concat([get_kmeans_dataframe_image(file_image_map[file]) for file in file_image_map.keys()])


file_image_map = get_file_image_map(photos_dir)
print("here")
df = get_kmeans_dataframe_all_photos(file_image_map)
print("done")
print(df)
exit()

file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img



img = Image.open(target_photo)
img = scale_image_to_basewidth(img, basewidth=50)


def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)


file_image_map = get_file_image_map(photos_dir)
print("here")
df = get_kmeans_dataframe_all_photos(file_image_map)
print("done")
df.to_csv("kmean_data_all_photos.csv",index=False)
print(df)
exit()

file_avgPixel_map = get_file_avgPixelMap(file_image_map)



pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div><button type='button' class='collapsible active'>+ print(kmeans_dataframe)</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)


file_image_map = get_file_image_map(photos_dir)

first_run = False

if first_run:
    kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
    kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
else:
    kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")


file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

all_centroids = kmeans_dataframe["centroid"].values
print(all_centroids)

nearest_neighbors_tree = KDTree(all_centroids)
img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_centroids[pixel_index]
        closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]["filename"].values
        closest_file = closest_files[0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

"""
#if pixel average method:

file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)
"""




column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)


file_image_map = get_file_image_map(photos_dir)

first_run = False

if first_run:
    kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
    kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
else:
    kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")


print(kmeans_dataframe)
all_centroids = kmeans_dataframe["centroid"].values.astype(tuple)
print(tuple("(1,2)"))
#print(all_centroids)

nearest_neighbors_tree = KDTree(all_centroids)
img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_centroids[pixel_index]
        closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]["filename"].values
        closest_file = closest_files[0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

"""
#if pixel average method:

file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)
"""




column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div></div>
<button type='button' class='collapsible active'>+     kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

file_image_map = get_file_image_map(photos_dir)

first_run = False

if first_run:
    kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
    kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
else:
    kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")

print(int(" 42"), string_to_tuple("(228, 130, 14)"))
print(kmeans_dataframe)
all_centroids = kmeans_dataframe["centroid"]
exit()
#print(all_centroids)

nearest_neighbors_tree = KDTree(all_centroids)
img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_centroids[pixel_index]
        closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]["filename"].values
        closest_file = closest_files[0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

"""
#if pixel average method:

file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)
"""




column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

file_image_map = get_file_image_map(photos_dir)

first_run = False

if first_run:
    kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
    kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
else:
    kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
    kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

print(int(" 42"), string_to_tuple("(228, 130, 14)"))
print(kmeans_dataframe)

all_centroids = kmeans_dataframe["centroid"].values
print(all_centroids)

nearest_neighbors_tree = KDTree(all_centroids)
img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_centroids[pixel_index]
        closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]["filename"].values
        closest_file = closest_files[0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

"""
#if pixel average method:

file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)
"""




column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+ def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

file_image_map = get_file_image_map(photos_dir)

first_run = False

if first_run:
    kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
    kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
else:
    kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
    kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

print(kmeans_dataframe)

all_centroids = kmeans_dataframe["centroid"].values
print(all_centroids)

for c in all_centroids:
    print(sum(c))

nearest_neighbors_tree = KDTree(all_centroids)
img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_centroids[pixel_index]
        closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]["filename"].values
        closest_file = closest_files[0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)

"""
#if pixel average method:

file_avgPixel_map = get_file_avgPixelMap(file_image_map)
pixel_files_map = get_pixel_files_map(file_avgPixel_map)
all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

print("files", len(os.listdir(photos_dir)))
print("images", len(file_avgPixel_map.keys()))

nearest_neighbors_tree = KDTree(all_avg_pixels)

img = Image.open(target_photo)

img = scale_image_to_basewidth(img, basewidth=50)
image_matrix = img.load()
width, height = img.size

for y in range(height):
    for x in range(width):
        pixel = image_matrix[x,y]
        nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
        pixel_index = nearest_neighbors[1][random.randint(0, 9)]
        neighbor_pixel = all_avg_pixels[pixel_index]
        closest_file = pixel_files_map[neighbor_pixel][0]
        closest_img = file_image_map[closest_file]
        closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
       
        if x == 0:
            row_image = closest_img_resized
        else:
            row_image = get_concat_h(row_image, closest_img_resized)
        image_matrix[x,y] = neighbor_pixel
    if y == 0:
        column_image = row_image
    else:
        column_image = get_concat_v(column_image, row_image)
"""




column_image.save("mosaic.jpg")


img.save("recolored_image.jpg")
closest_img_resized.save("closest_img_draft.jpg")
#img.save("resized_image.jpg")

# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


img = Image.open("target_angie.jpg")
img.draft("RGB",(50,50))
image_matrix = img.load()


img2 = Image.open("target_photo.jpg")
img2.draft("RGB",(50,50))
image_matrix2 = img2.load()


#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
<button type='button' class='collapsible active'>search: python jpg similarity</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=python+image+similarity&rlz=1C5CHFA_enUS863US865&oq=python+image+simila&aqs=chrome.0.0i512j69i57j0i512l4j0i22i30i625l4.3911j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>python image similarity</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n155_2023-02-16-17_48_59-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://betterprogramming.pub/how-to-measure-image-similarities-in-python-12f1cb2b7281' target='_blank' rel='noreferrer noopener'>How To Measure Image Similarities In Python | Better Programming</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n156_2023-02-16-17_49_08-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://towardsdatascience.com/measuring-similarity-in-two-images-using-python-b72233eb53c6' target='_blank' rel='noreferrer noopener'>Measuring similarity in two images using Python | by Param Raval | Towards Data Science</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+image+similarity+pil&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzUfhCqKcO0xrCjMF8REiPlR3HRFKw%3A1676591329209&ei=4cDuY6WuDIuYptQPq5WFiA0&ved=0ahUKEwjlovG0nZv9AhULjIkEHatKAdEQ4dUDCBA&uact=5&oq=python+image+similarity+pil&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIJCAAQFhAeEPEEMgUIABCGAzIFCAAQhgMyBQgAEIYDMgUIABCGAzoKCAAQRxDWBBCwAzoECAAQQzoFCAAQgAQ6BggAEBYQHkoECEEYAFDaA1jOCWDFDmgBcAF4AIABlQGIAfMDkgEDMS4zmAEAoAEByAEIwAEB&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>python image similarity pil</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n158_2023-02-16-17_49_49-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/52736154/how-to-check-similarity-of-two-images-that-have-different-pixelization' target='_blank' rel='noreferrer noopener'>python - How to check similarity of two images that have different pixelization - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=python+jpg+similarity&rlz=1C5CHFA_enUS863US865&oq=python+jpg+similarity&aqs=chrome..69i57j33i160l2.3440j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>python jpg similarity</a></span></div><hr>
<div class='webImageLongRow'>
</div>
</div>
<button type='button' class='collapsible active'>search: numpy initialize array of strings</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=pil+image+to+numpy+array&rlz=1C5CHFA_enUS863US865&oq=pil+image+to+&aqs=chrome.1.69i57j0i512l4j69i60l3.5271j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>pil image to numpy array</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n162_2023-02-16-17_52_58-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/384759/how-do-i-convert-a-pil-image-into-a-numpy-array' target='_blank' rel='noreferrer noopener'>python - How do I convert a PIL Image into a NumPy array? - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+mean+square+error&rlz=1C5CHFA_enUS863US865&oq=numpy+mean+square+erro&aqs=chrome.0.0i512j69i57j0i22i30i625j0i22i30l6j0i390.3449j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>numpy mean square error</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n164_2023-02-16-17_58_10-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy' target='_blank' rel='noreferrer noopener'>python - Mean Squared Error in Numpy? - Stack Overflow</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n165_2023-02-16-18_08_05-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.hist.html' target='_blank' rel='noreferrer noopener'>matplotlib.pyplot.hist — Matplotlib 3.7.0 documentation</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n166_2023-02-16-21_52_33-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy' target='_blank' rel='noreferrer noopener'>python - Mean Squared Error in Numpy? - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+array+of+strings&rlz=1C5CHFA_enUS863US865&oq=numpy+array+of+strings&aqs=chrome..69i57j0i512l3j0i22i30i625j0i22i30l2j0i22i30i625j0i22i30l2.4567j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>numpy array of strings</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n168_2023-02-16-22_13_14-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://numpy.org/doc/stable/reference/generated/numpy.chararray.html' target='_blank' rel='noreferrer noopener'>numpy.chararray — NumPy v1.24 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n169_2023-02-16-22_14_23-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://numpy.org/doc/stable/reference/generated/numpy.matrix.T.html' target='_blank' rel='noreferrer noopener'>numpy.matrix.T — NumPy v1.24 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n170_2023-02-16-22_14_26-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://numpy.org/doc/stable/reference/generated/numpy.matrix.H.html' target='_blank' rel='noreferrer noopener'>numpy.matrix.H — NumPy v1.24 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n171_2023-02-16-22_14_36-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://numpy.org/doc/stable/reference/generated/numpy.record.html' target='_blank' rel='noreferrer noopener'>numpy.record — NumPy v1.24 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n172_2023-02-16-22_14_43-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://numpy.org/doc/stable/reference/arrays.classes.html' target='_blank' rel='noreferrer noopener'>Standard array subclasses — NumPy v1.24 Manual</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+initialize+array+of+strings&rlz=1C5CHFA_enUS863US865&oq=numpy+initialize+array+of+strings&aqs=chrome..69i57j0i22i30i625j0i22i30.5081j0j4&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>numpy initialize array of strings</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n174_2023-02-16-22_14_57-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/14639496/how-to-create-a-numpy-array-of-arbitrary-length-strings' target='_blank' rel='noreferrer noopener'>python - How to create a numpy array of arbitrary length strings? - Stack Overflow</a></td></tr></tbody></table></div>
</div>
</div>
</div>
</div>
</div>
<button type='button' class='collapsible active'>+ img = Image.open("mosaic_avg.jpg")
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


img = Image.open("target_angie.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)
print(arr.shape)

img2 = Image.open("target_photo.jpg")
img2.draft("RGB",(50,50))
image_matrix2 = img2.load()


#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


img = Image.open("mosaic_avg.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("angie_flower.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+ img2 = Image.open("angie_bed2.jpg")
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("angie_bed2.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("angie_bed2.jpg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+             img = img.resize((50, 50), Image.ANTIALIAS)
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            #print(img)
            #.resize((50, 50), Image.ANTIALIAS)
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image


img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)
file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 90:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img#.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+     filename_matrix = np.chararray((width, height)) #parallel matrix to what we're building
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = np.zeros((width, height)) #parallel matrix to what we"re building

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img#.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[x,y] = closest_file
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = np.chararray((width, height)) #parallel matrix to what we"re building

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img#.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[x,y] = closest_file
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+     filename_matrix = np.array([["" for i in range(height)] for j in range(width)]) #parallel matrix to what we're building
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = [["" for i in range(width)] for j in range(height)] #parallel matrix to what we"re building

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img#.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[x,y] = closest_file
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = np.array([["" for i in range(height)] for j in range(width)]) #parallel matrix to what we"re building

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img#.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[x,y] = closest_file
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+     filename_matrix = []
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = np.array([["" for i in range(height)] for j in range(width)]) #parallel matrix to what we"re building

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            neighbor_pixel = all_avg_pixels[pixel_index]
            closest_file = pixel_files_map[neighbor_pixel][0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img#.resize((50, 50), Image.ANTIALIAS)
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[x,y] = closest_file
            print(filename_matrix[x,y], closest_file)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 2
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2

    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = unique_photos_necessary_in_window)[1]
            for pixel_index in nearest_neighbors_indexes:
                #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                neighbor_pixel = all_avg_pixels[pixel_index]
                neighbor_file = pixel_files_map[neighbor_pixel][0]
                neighbor_image = file_image_map[neighbor_file]

                window_x_min = max(0, x-min_array_distance_between_similar_photos)
                window_y_min = max(0, y-min_array_distance_between_similar_photos)
                for window_y in range(window_y_min, y):
                    for window_x in range(window_x_min, x):
                        if not (window_y == y and window_x == x):
                            window_file = filename_matrix[window_y][window_x]
                closest_img = neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(closest_file)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+             valid_image_found = False
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 2
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2

    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = unique_photos_necessary_in_window)[1]
            for pixel_index in nearest_neighbors_indexes:
                #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                neighbor_pixel = all_avg_pixels[pixel_index]
                neighbor_file = pixel_files_map[neighbor_pixel][0]
                neighbor_image = file_image_map[neighbor_file]

                window_x_min = max(0, x-min_array_distance_between_similar_photos)
                window_y_min = max(0, y-min_array_distance_between_similar_photos)
                for window_y in range(window_y_min, y):
                    for window_x in range(window_x_min, x):
                        if not (window_y == y and window_x == x):
                            window_file = filename_matrix[window_y][window_x]
                closest_img = neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(neighbor_file)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 2
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2

    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = unique_photos_necessary_in_window)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)

                    valid_image_found = False
                    for window_y in range(window_y_min, y):
                        for window_x in range(window_x_min, x):
                            if not (window_y == y and window_x == x):
                                window_file = filename_matrix[window_y][window_x]
                                window_img = file_image_map[window_file]
                                image_distance = compare_image_distance(neighbor_image, window_img)
                                if image_distance > 85:
                                    valid_image_found = True
                                    image_toAdd = neighbor_image

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(neighbor_file)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+ def compare_image_distance(img1, img2):
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple


def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 2
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2

    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = unique_photos_necessary_in_window)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                    else: 
                        for window_y in range(window_y_min, y):
                            for window_x in range(window_x_min, x):
                                if not (window_y == y and window_x == x):
                                    window_file = filename_matrix[window_y][window_x]
                                    window_img = file_image_map[window_file]
                                    image_distance = compare_image_distance(neighbor_image, window_img)
                                    if image_distance > 85:
                                        valid_image_found = True
                                        image_toAdd = neighbor_image

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(neighbor_file)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    print(filename_matrix)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()
img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 2
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2

    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = unique_photos_necessary_in_window)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        isValid = True #starts true, then gets disqualified potentially
                        for window_y in range(window_y_min, y):
                            if not valid_image_found:
                                for window_x in range(window_x_min, x):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x == x):
                                            
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            print(image_distance)
                                            if image_distance < 85:
                                                isValid = False
                            if isValid:
                                print("valid image found!")
                                valid_image_found = True
                                image_toAdd = neighbor_image
                                filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()

img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+     min_array_distance_between_similar_photos = 3
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 2
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2

    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = unique_photos_necessary_in_window)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd =4
                        isValid = True #starts true, then gets disqualified potentially
                        print("NEXT")
                        for window_y in range(window_y_min, y):
                            if not valid_image_found:
                                for window_x in range(window_x_min, x):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x == x):
                                            window_file = filename_matrix[window_y][window_x]
                                            #print("\t", "y",window_y, "x", window_x, window_file)
                                            window_img = file_image_map[window_file]
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        if isValid:
                            print("valid image found!")
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()

img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 3
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, x+1 + min_array_distance_between_similar_photos):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            #print("\t", "y",window_y, "x", window_x, window_file)
                                            window_img = file_image_map[window_file]
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()

img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+ def compare_image_to_images_distances(neighbor_image, window_imgs):
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 3
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            #print("\t", "y",window_y, "x", window_x, window_file)
                                            window_img = file_image_map[window_file]
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()

img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    arr_images = np.array([np.array(x) for x in window_imgs])
    MSEs = ((arr_img-arr_img)**2).mean().mean()
    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=80)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 7
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            # image_distance = compare_image_distance(neighbor_image, window_img)
                                            # if image_distance < 85:
                                            #     isValid = False
                        image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        print(image_distances)
                        exit()
                        if image_distances.max() < 85:
                            isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()

img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+     print(MSEs.shape)
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    arr_images = np.array([np.array(x) for x in window_imgs])
    MSEs = ((arr_img-arr_img)**2)
    print(MSEs)
    #MSEs.mean().mean()

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=80)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 7
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            # image_distance = compare_image_distance(neighbor_image, window_img)
                                            # if image_distance < 85:
                                            #     isValid = False
                        image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        print(image_distances)
                        exit()
                        if image_distances.max() < 85:
                            isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir)
img.save("mosaic.jpg")
exit()

img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    arr_images = np.array([np.array(x) for x in window_imgs])
    MSEs = ((arr_img-arr_img)**2)
    print(MSEs.shape)
    print(MSEs.mean().shape)
    print(MSEs.mean())
    #MSEs.mean().mean()

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=80)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 7
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            # image_distance = compare_image_distance(neighbor_image, window_img)
                                            # if image_distance < 85:
                                            #     isValid = False
                        image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        print(image_distances)
                        exit()
                        if image_distances.max() < 85:
                            isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir)
# img.save("mosaic.jpg")
# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

vector_arr = np.array([arr2 for i in range(10)])
print(vector_arr.shape, arr.shape)


exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>+     vector_arr = np.array([np.array(x) for x in window_imgs])
</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    arr_images = np.array([np.array(x) for x in window_imgs])
    MSEs = ((arr_img-arr_img)**2)
    print(MSEs.shape)
    print(MSEs.mean().shape)
    print(MSEs.mean())
    #MSEs.mean().mean()

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=80)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 7
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            # image_distance = compare_image_distance(neighbor_image, window_img)
                                            # if image_distance < 85:
                                            #     isValid = False
                        image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        print(image_distances)
                        exit()
                        if image_distances.max() < 85:
                            isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir)
# img.save("mosaic.jpg")
# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)

vector_arr = np.array([arr2 for i in range(10)])
print(vector_arr.shape, arr.shape)
print((vector_arr - arr).mean(axis=1).mean(axis=1).shape)


exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

print(((vector_arr - vector_arr.T)**2).mean(axis=1).mean(axis=1).mean(axis=1))

exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div>
<button type='button' class='collapsible active'>search: numpy matrix operations</button>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=python+subtract+arrays+of+vectors&rlz=1C5CHFA_enUS863US865&oq=python+subtract+arrays+of+vectors&aqs=chrome..69i57j33i160j33i299j33i22i29i30l3.21615j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>python subtract arrays of vectors</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+random+array+of+shape&rlz=1C5CHFA_enUS863US865&oq=numpy+random+array+of+shape&aqs=chrome..69i57j0i512j0i22i30i625l4j0i22i30l2j0i22i30i625.2744j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>numpy random array of shape</a></span></div><hr>
<div class='webImageLongRow'>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+MSE+of+multiple+parallel+arrays&rlz=1C5CHFA_enUS863US865&oq=numpy+MSE+of+multiple+parallel+arrays&aqs=chrome..69i57j33i160.6473j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>numpy MSE of multiple parallel arrays</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n182_2023-02-17-11_46_53-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/51435992/python-fast-mean-squared-error-between-two-large-2d-lists' target='_blank' rel='noreferrer noopener'>performance - python fast mean squared error between two large 2d lists - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+MSE+of+multiple+parallel+3d+arrays&rlz=1C5CHFA_enUS863US865&sxsrf=AJOqlzXV4s7_-3Q7LjZUBLEbS-nTY0N6-g%3A1676656007893&ei=h73vY6WENqugptQPyrikqAk&ved=0ahUKEwjl44qujp39AhUrkIkEHUocCZUQ4dUDCBA&uact=5&oq=numpy+MSE+of+multiple+parallel+3d+arrays&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCAAQogQyBQgAEKIEMgUIABCiBDIFCAAQogQyCggAEPEEEB4QogQ6CggAEEcQ1gQQsAM6BAgjECdKBAhBGABQzghYswxg_RFoAXAAeACAAYABiAGlApIBAzIuMZgBAKABAcgBCMABAQ&sclient=gws-wiz-serp' target='_blank' rel='noreferrer noopener'>numpy MSE of multiple parallel 3d arrays</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n184_2023-02-17-11_47_48-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://stackoverflow.com/questions/66236344/compute-root-mean-squared-error-and-obtain-a-3d-array-in-python' target='_blank' rel='noreferrer noopener'>numpy - Compute Root Mean Squared Error and obtain a 3D array in Python - Stack Overflow</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=numpy+matrix+operations&rlz=1C5CHFA_enUS863US865&oq=numpy+matrix+operations&aqs=chrome.0.0i512l2j0i22i30l3j0i22i30i625j0i22i30j0i22i30i625j0i22i30l2.6033j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>numpy matrix operations</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n186_2023-02-17-11_55_55-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://towardsdatascience.com/top-10-matrix-operations-in-numpy-with-examples-d761448cb7a8' target='_blank' rel='noreferrer noopener'>Top 10 Matrix Operations in Numpy with Examples | by Rukshan Pramoditha | Towards Data Science</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n187_2023-02-17-11_56_04-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://numpy.org/doc/stable/reference/generated/numpy.matrix.html' target='_blank' rel='noreferrer noopener'>numpy.matrix — NumPy v1.24 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n188_2023-02-17-11_56_26-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://numpy.org/doc/stable/reference/generated/numpy.matrix.T.html' target='_blank' rel='noreferrer noopener'>numpy.matrix.T — NumPy v1.24 Manual</a></td></tr></tbody></table></div>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n189_2023-02-17-13_57_57-need-manual.png' width='180' height='112'> </td></tr><tr><td bgColor='lightblue'> <a href='https://stackoverflow.com/questions/66236344/compute-root-mean-squared-error-and-obtain-a-3d-array-in-python' target='_blank' rel='noreferrer noopener'>numpy - Compute Root Mean Squared Error and obtain a 3D array in Python - Stack Overflow</a></td></tr></tbody></table></div>
</div>

<button type='button' class='collapsible active'>+ vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

print(((vector_arr - vector_arr)**2).mean(axis=0))

exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])

#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

print(((vector_arr - vector_arr2)**2).mean(axis=1).mean(axis=1))

exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div><button type='button' class='collapsible active'>target_photo = "angie_flower.jpeg"</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])

#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

print(((vector_arr - vector_arr2)**2).mean(axis=0).mean(axis=1))

exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])

#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

print(((vector_arr - vector_arr2)**2).mean(axis=0).mean(axis=1))

exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div><button type='button' class='collapsible active'>+ print(((vector_arr - vector_arr2)**2).shape)</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])

#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

print(((vector_arr - vector_arr2)**2))

exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])

#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

print(((vector_arr - vector_arr2)**2).shape)

exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div><button type='button' class='collapsible active'>+ vector_arr = np.array([np.ones((3, 3, 4)), np.zeros((3, 3, 4)), randarr])</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])

#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

randarr =  np.random.rand(3,3,4)
print(randarr, randarr.shape)

vector_arr = np.array([np.ones((3, 3, 4)), np.zeros((3, 3, 4))])
vector_arr2 = np.array([np.zeros((3, 3, 4)), np.ones((3, 3, 4))])
print(vector_arr.shape)
Es = (vector_arr - vector_arr2)
print(Es)
print(Es.shape)
print(Es.mean(axis=1).mean(axis=1).mean(axis=1))

exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])

#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

randarr =  np.random.rand(3,3,4)
print(randarr, randarr.shape)

vector_arr = np.array([np.ones((3, 3, 4)), np.zeros((3, 3, 4)), randarr])
vector_arr2 = np.array([randarr, np.zeros((3, 3, 4)), np.ones((3, 3, 4))])
print(vector_arr.shape)
Es = (vector_arr - vector_arr2)
print(Es)
print(Es.shape)
print(Es.mean(axis=1).mean(axis=1).mean(axis=1))


exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div><button type='button' class='collapsible active'>+ print(Es.mean(axis=1).mean(axis=2))</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])

#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

randarr =  np.random.rand(3,3,4)
print(randarr, randarr.shape)

vector_arr = np.array([np.ones((3, 3, 4)), np.zeros((3, 3, 4)), randarr])
vector_arr2 = np.array([randarr, np.zeros((3, 3, 4)), np.ones((3, 3, 4))])
print(vector_arr.shape)
Es = (vector_arr - vector_arr2)
print(Es)
print(Es.shape)
print(Es.mean(axis=1).mean(axis=1))


exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])

#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

randarr =  np.random.rand(3,3,4)
print(randarr, randarr.shape)

vector_arr = np.array([np.ones((3, 3, 4)), np.zeros((3, 3, 4)), randarr])
vector_arr2 = np.array([randarr, np.zeros((3, 3, 4)), np.ones((3, 3, 4))])
print(vector_arr.shape)
Es = (vector_arr - vector_arr2)
print(Es)
print(Es.shape)
print(Es.mean(axis=1).mean(axis=2))


exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div><button type='button' class='collapsible active'>+ print(Es.mean(axis=3))</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])

#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

randarr =  np.random.rand(3,3,4)
print(randarr, randarr.shape)

vector_arr = np.array([np.ones((3, 3, 4)), np.zeros((3, 3, 4)), randarr])
vector_arr2 = np.array([randarr, np.zeros((3, 3, 4)), np.ones((3, 3, 4))])
print(vector_arr.shape)
Es = (vector_arr - vector_arr2)
print(Es)
print(Es.shape)
print(Es.mean(axis=1))


exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])

#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

randarr =  np.random.rand(3,3,4)
print(randarr, randarr.shape)

vector_arr = np.array([np.ones((3, 3, 4)), np.zeros((3, 3, 4)), randarr])
vector_arr2 = np.array([randarr, np.zeros((3, 3, 4)), np.ones((3, 3, 4))])
print(vector_arr.shape)
Es = (vector_arr - vector_arr2)
print(Es)
print(Es.shape)
print(Es.mean(axis=3))


exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div><button type='button' class='collapsible active'>+ def get_all_image_comparisons_matrix(file_image_map):</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_img = file_image_map[window_file]
                                            window_imgs.append(window_img)
                                            image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



# img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
# img.save("mosaic.jpg")

# exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

arr3 = np.array(img3)

vector_arr = np.array([arr2, arr3])#np.array([arr2 for i in range(10)])
vector_arr2 = np.array([arr3, arr2])#np.array([arr2 for i in range(10)])

#vector_arr = np.array([arr2])
print(vector_arr.shape, arr.shape)
print(((vector_arr - arr)**2).mean(axis=1).mean(axis=1).mean(axis=1))

randarr =  np.random.rand(3,3,4)
print(randarr, randarr.shape)

vector_arr = np.array([np.ones((3, 3, 4)), np.zeros((3, 3, 4)), randarr])
vector_arr2 = np.array([randarr, np.zeros((3, 3, 4)), np.ones((3, 3, 4))])
print(vector_arr.shape)
Es = (vector_arr - vector_arr2)
print(Es)
print(Es.shape)
print(Es.mean(axis=3).shape)


exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def get_all_image_comparisons_matrix(file_image_map):
    file_index_map = {}
    index = 0
    all_distances = []
    for file in file_image_map.keys():
        file_distances = []
        img = file_image_map[file]
        file_index_map[file] = index
        index += 1
        for compare_file in file_image_map.keys():
            compare_image = file_image_map[compare_file]
            distance = compare_image_distance(img, compare_image)
            file_distances.append(distance)
    return file_index_map, all_distances

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    file_index_map, all_distances_matrix = get_all_image_comparisons_matrix(file_image_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]
                    neighbor_distance_index = file_index_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_file_index = file_index_map[window_file]
                                            image_distance = all_distances_matrix[neighbor_distance_index][window_file_index]
                                            # window_img = file_image_map[window_file]
                                            # window_imgs.append(window_img)
                                            # image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
img.save("mosaic.jpg")

exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div><button type='button' class='collapsible active'>+ def get_file_image_map(photos_dir, width=50):</button>
<div class='content' --start-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir):
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(50,50))
            img = img.resize((50, 50), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def get_all_image_comparisons_matrix(file_image_map):
    file_index_map = {}
    index = 0
    all_distances = []
    for file in file_image_map.keys():
        file_distances = []
        img = file_image_map[file]
        file_index_map[file] = index
        index += 1
        for compare_file in file_image_map.keys():
            compare_image = file_image_map[compare_file]
            distance = compare_image_distance(img, compare_image)
            file_distances.append(distance)
        all_distances.append(file_distances)
    print(np.array(all_distances).shape)
    return file_index_map, all_distances

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50):
    file_image_map = get_file_image_map(photos_dir)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    file_index_map, all_distances_matrix = get_all_image_comparisons_matrix(file_image_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 100)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]
                    neighbor_distance_index = file_index_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_file_index = file_index_map[window_file]
                                            image_distance = all_distances_matrix[neighbor_distance_index][window_file_index]
                                            # window_img = file_image_map[window_file]
                                            # window_imgs.append(window_img)
                                            # image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir, basewidth=50)
img.save("mosaic.jpg")

exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up' --end-code='# import imageio.v3 as iio

target_photo = "angie_flower.jpeg"
# photo = iio.imread(target_photo)
# print(photo.shape)
from PIL import Image
import numpy as np
import os
import pickle
from scipy.spatial import KDTree
import random
from sklearn.cluster import KMeans, OPTICS
import pandas as pd

photos_dir = "Photos/"

def get_avg_pixel(img):
     resized_image = img.resize((1,1), Image.ANTIALIAS)
     pixels = resized_image.load()
     return pixels[0,0]

def get_file_avgPixelMap(file_image_map):
    file_avgPixel_map = {}
    for file in file_image_map.keys():
        img = file_image_map[file]
        try:
             pixel = get_avg_pixel(img)
             file_avgPixel_map[file] = pixel
        except:
             print("ERROR", file)
    return file_avgPixel_map
        
def get_file_avgPixelMap_old(photos_dir):
    photo_pixel_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB", (1,1))
            try:
                pixel = get_avg_pixel(img)
                photo_pixel_map[filename] = pixel
            except:
                print("Error:",filename)
    return photo_pixel_map

def get_file_image_map(photos_dir, width=50):
    height = width #square image
    file_image_map = {}
    for filename in os.listdir(photos_dir):
        if filename.endswith(".jpg"):
            img = Image.open(photos_dir+filename)
            img.draft("RGB",(width,height))
            img = img.resize((width, height), Image.ANTIALIAS)
            
            file_image_map[filename] = img
    return file_image_map

def get_concat_h(im1, im2):
    dst = Image.new("RGB", (im1.width + im2.width, im1.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_v(im1, im2):
    dst = Image.new("RGB", (im1.width, im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

def get_pixel_files_map(pixel_map):
    pixel_files_map = {}
    #create map from pixel value to list of files with that avg pixel
    for filename in pixel_map.keys():
        avg_pixel_value = pixel_map[filename]
        if avg_pixel_value in pixel_files_map.keys():
            pixel_files_map[avg_pixel_value].append(filename)
        else:
            pixel_files_map[avg_pixel_value] = [filename]
    return pixel_files_map

def get_all_avg_pixels_array(file_image_map):
    all_avg_pixels = []
    for filename in file_image_map.keys():
        all_avg_pixels.append(file_image_map[filename])
    return all_avg_pixels

def scale_image_to_basewidth(img, basewidth=50):
    wpercent = (basewidth / float(img.size[0]))
    hsize = int((float(img.size[1]) * float(wpercent)))
    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
    return img

def get_kmeans_dataframe_all_photos(file_image_map):
    all_rows = []
    table_columns = ["filename","centroid","percent"]
    for file in file_image_map.keys():
        print(file)
        img = file_image_map[file]

        pixels = np.array(img.getdata())
        kmeans = KMeans(n_clusters=4).fit(pixels)
        centroids = kmeans.cluster_centers_.astype(int)
        
        predictions = kmeans.predict(pixels)
        centroid_indexes, counts = np.unique(predictions, return_counts = True)
        percentages = counts / counts.sum()
        for percent, centroid in zip(percentages, centroids):
            #skip if percent < threshold
            all_rows.append([file, tuple(centroid), percent])
    return pd.DataFrame(all_rows, columns=table_columns)

def string_to_tuple(s):
    s = s[1:-1]
    myTuple = tuple([int(number) for number in s.split(",")])
    return myTuple

def compare_image_distance(img1, img2):
    arr = np.array(img1)
    arr2 = np.array(img2)
    mse = ((arr-arr2)**2).mean().mean()
    return mse

def compare_image_to_images_distances(neighbor_image, window_imgs):
    arr_img = np.array(neighbor_image)
    vector_arr = np.array([np.array(x) for x in window_imgs])
    MSEs = ((vector_arr - arr_img)**2).mean(axis=1).mean(axis=1).mean(axis=1)

    return MSEs

def get_all_image_comparisons_matrix(file_image_map):
    file_index_map = {}
    index = 0
    all_distances = []
    for file in file_image_map.keys():
        file_distances = []
        img = file_image_map[file]
        file_index_map[file] = index
        index += 1
        for compare_file in file_image_map.keys():
            compare_image = file_image_map[compare_file]
            distance = compare_image_distance(img, compare_image)
            file_distances.append(distance)
        all_distances.append(file_distances)
    print(np.array(all_distances).shape)
    return file_index_map, all_distances

def make_mosaic_kmeans(target_photo, photos_dir="Photos/"):
    file_image_map = get_file_image_map(photos_dir)
    first_run = False

    if first_run:
        kmeans_dataframe = get_kmeans_dataframe_all_photos(file_image_map)
        kmeans_dataframe.to_csv("kmean_data_all_photos.csv",index=False)
    else:
        kmeans_dataframe = pd.read_csv("kmean_data_all_photos.csv")
        kmeans_dataframe["centroid"] = kmeans_dataframe["centroid"].map(string_to_tuple)

    print(kmeans_dataframe)

    all_centroids = kmeans_dataframe["centroid"].tolist()

    nearest_neighbors_tree = KDTree(all_centroids)
    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=50)
    image_matrix = img.load()
    width, height = img.size

    for y in range(height):
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors = nearest_neighbors_tree.query(pixel, k = 10)
            closest_files_dfs = []
            for i in range(10):    
                pixel_index = nearest_neighbors[1][i]#[random.randint(0, 9)]
                neighbor_pixel = all_centroids[pixel_index]
                closest_files = kmeans_dataframe[kmeans_dataframe["centroid"] == neighbor_pixel]#["filename"].values
                closest_files_dfs.append(closest_files)
            closest_files_df = pd.concat(closest_files_dfs)
            print(closest_files_df.shape)
            closest_file = closest_files_df.sort_values("percent",ascending=False)["filename"].values[random.randint(0, 9)]
            #closest_file = closest_files[0]
            closest_img = file_image_map[closest_file]
            closest_img_resized = closest_img
        
            if x == 0:
                row_image = closest_img_resized
            else:
                row_image = get_concat_h(row_image, closest_img_resized)
            image_matrix[x,y] = neighbor_pixel
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)

def make_mosaic_avg(target_photo, photos_dir="Photos/", basewidth=50, pixelWidth=50):
    file_image_map = get_file_image_map(photos_dir, width = pixelWidth)
    file_avgPixel_map = get_file_avgPixelMap(file_image_map)
    pixel_files_map = get_pixel_files_map(file_avgPixel_map)
    all_avg_pixels = get_all_avg_pixels_array(file_avgPixel_map)

    file_index_map, all_distances_matrix = get_all_image_comparisons_matrix(file_image_map)

    print("files", len(os.listdir(photos_dir)))
    print("images", len(file_avgPixel_map.keys()))

    nearest_neighbors_tree = KDTree(all_avg_pixels)

    img = Image.open(target_photo)

    img = scale_image_to_basewidth(img, basewidth=basewidth)
    image_matrix = img.load()
    width, height = img.size
    
    filename_matrix = []

    min_array_distance_between_similar_photos = 5
    unique_photos_necessary_in_window = (min_array_distance_between_similar_photos + 1)**2
    prev_filename = "prevFile"
    for y in range(height):
        filename_matrix.append([])
        for x in range(width):
            pixel = image_matrix[x,y]
            nearest_neighbors_indexes = nearest_neighbors_tree.query(pixel, k = 200)[1]

            valid_image_found = False
            for pixel_index in nearest_neighbors_indexes:
                if not valid_image_found:
                    #search for a neighbor that fits the constraint of not being in the last min_distance rows or columns, then break
                    neighbor_pixel = all_avg_pixels[pixel_index]
                    neighbor_file = pixel_files_map[neighbor_pixel][0]
                    neighbor_image = file_image_map[neighbor_file]
                    neighbor_distance_index = file_index_map[neighbor_file]

                    window_x_min = max(0, x-min_array_distance_between_similar_photos)
                    window_y_min = max(0, y-min_array_distance_between_similar_photos)
                    window_x_max = min(width-1, x+min_array_distance_between_similar_photos)
                    if x == 0 and y == 0:
                       image_toAdd = neighbor_image
                       filename_toAdd = neighbor_file
                    else: 
                        image_toAdd = 4 #this is for debugging to ensure we don"t accidentally recycle this variable in the loop
                        isValid = True #starts true, then gets disqualified potentially
                        window_imgs = []
                        for window_y in range(window_y_min, y+1):
                            if not valid_image_found:
                                for window_x in range(window_x_min, window_x_max + 1):
                                    if not valid_image_found:
                                        if not (window_y == y and window_x >= x):
                                            window_file = filename_matrix[window_y][window_x]
                                            window_file_index = file_index_map[window_file]
                                            image_distance = all_distances_matrix[neighbor_distance_index][window_file_index]
                                            # window_img = file_image_map[window_file]
                                            # window_imgs.append(window_img)
                                            # image_distance = compare_image_distance(neighbor_image, window_img)
                                            if image_distance < 85:
                                                isValid = False
                        # image_distances = compare_image_to_images_distances(neighbor_image, window_imgs)
                        # print(image_distances)
                        # if image_distances.min() < 85:
                        #     isValid = False
                        if isValid:
                            valid_image_found = True
                            image_toAdd = neighbor_image
                            filename_toAdd = neighbor_file

                closest_img = image_toAdd# neighbor_image # this is a bug and only to get things running to test above indexing. do not keep!
            #old method of picking random of top 10 avg results
            # pixel_index = nearest_neighbors[1][random.randint(0, 9)]
            # neighbor_pixel = all_avg_pixels[pixel_index]
            # closest_file = pixel_files_map[neighbor_pixel][0]
            # closest_img = file_image_map[closest_file]
        
            if x == 0:
                row_image = closest_img
            else:
                row_image = get_concat_h(row_image, closest_img)
            #image_matrix[x,y] = neighbor_pixel
            filename_matrix[y].append(filename_toAdd)
            if prev_filename == filename_toAdd:
                print(prev_filename, "twice in a row!!")
            prev_filename = filename_toAdd
        if y == 0:
            column_image = row_image
        else:
            column_image = get_concat_v(column_image, row_image)
    return column_image



img = make_mosaic_avg(target_photo, photos_dir, basewidth=60, pixelWidth=200)
img.save("mosaic_flowers_low.jpg")

exit()




img = Image.open("angie_bed1.jpg")
img.draft("RGB",(50,50))
img = img.resize((50, 50), Image.ANTIALIAS)
image_matrix = img.load()

arr = np.array(img)

print(arr.shape)

img2 = Image.open("colorwheel.jpeg")
img2.draft("RGB",(50,50))
img2 = img2.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img2.load()

arr2 = np.array(img2)


img3 = Image.open("angie_bed2.jpg")
img3.draft("RGB",(50,50))
img3 = img3.resize((50, 50), Image.ANTIALIAS)

image_matrix2 = img3.load()

exit()
mse = ((arr-arr2)**2).mean().mean()
print(mse)

file_image_map = get_file_image_map(photos_dir)

file_image_resized_map = {}
for file in file_image_map.keys():
    file_image_resized_map[file] = file_image_map[file].resize((50,50), Image.ANTIALIAS)

for file in file_image_map.keys():
    img2 = file_image_resized_map[file]
    image_matrix2 = img2.load()
    arr2 = np.array(img2)

    mse = ((arr-arr2)**2).mean().mean()
    if mse < 85:
        print(file, mse)





#mosaic_image = make_mosaic_avg(target_photo, photos_dir)
#mosaic_image.save("mosaic.jpg")




# fun idea, a huge recursive photomosaic
# idea: photo cant border itself--force the next neighbor to step up'>
<p> code content will go here</p>
</div></div>
<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=2400x1200+dpi&rlz=1C5CHFA_enUS863US865&oq=2400x1200+dpi&aqs=chrome..69i57j0i10i512j0i10i22i30j0i15i22i30j0i22i30i625j0i390l4.6072j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>2400x1200 dpi</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n191_2023-02-17-15_29_18-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.dpreview.com/forums/thread/3035616' target='_blank' rel='noreferrer noopener'>How much can 2400 x 1200 DPI resolve?: Printers and Printing Forum: Digital Photography Review</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=what+does+dpi+mean+printer&rlz=1C5CHFA_enUS863US865&oq=what+does+dpi+mean+printer&aqs=chrome..69i57j0i390l3.4155j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>what does dpi mean printer</a></span></div><hr>
<div class='webImageLongRow'>
</div>

<div class='content'>
<div class='title'><span><a href='https://www.google.com/search?q=2400x1200+dpi&rlz=1C5CHFA_enUS863US865&oq=2400x1200+dpi&aqs=chrome..69i57j0i10i512j0i10i22i30j0i15i22i30j0i22i30i625j0i390l4.6072j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>2400x1200 dpi</a></span></div><hr>
<div class='webImageLongRow'>
	<div class='sideBySideImage'> <table><tbody><tr><td><img src='/images/gitMosaic/screencapture-n191_2023-02-17-15_29_18-need-manual.png' width='180' height='112'> </td></tr><tr><td><a href='https://www.dpreview.com/forums/thread/3035616' target='_blank' rel='noreferrer noopener'>How much can 2400 x 1200 DPI resolve?: Printers and Printing Forum: Digital Photography Review</a></td></tr></tbody></table></div>
</div>
<div class='title'><span><a href='https://www.google.com/search?q=what+does+dpi+mean+printer&rlz=1C5CHFA_enUS863US865&oq=what+does+dpi+mean+printer&aqs=chrome..69i57j0i390l3.4155j0j7&sourceid=chrome&ie=UTF-8' target='_blank' rel='noreferrer noopener'>what does dpi mean printer</a></span></div><hr>
<div class='webImageLongRow'>
</div>

